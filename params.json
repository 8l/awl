{"name":"Awl","tagline":"Experimental Lispy mini-language","body":"# Awl\r\n\r\n_Lisp_: from late Old English _awlyspian_, meaning \"to lisp.\"\r\n\r\n---\r\n\r\nAwl is an experimental mini-language based on the Lisp family of programming\r\nlanguages.\r\n\r\nIt was written for fun and ~~profit~~ to learn more about interpreter design,\r\nprogramming in C, and using [emscripten](https://github.com/kripken/emscripten)\r\nto transpile to JavaScript.\r\n\r\n**Note**: This naturally goes without saying, but Awl is just an experimental\r\nlearning project. It should *not* be used for production code. That being said,\r\nexperimenting and hacking on non-production-ready code just for fun is usually\r\nworthwhile!\r\n\r\n## Compiling\r\n\r\nMost of awl's dependencies are included in the repository, so you shouldn't\r\nneed to install anything other than the build tools. Awl takes advantage of\r\nsome new features in C11, so you will need a fairly recent C compiler.\r\n\r\n- Both `clang` (tested with version 3.5.0) and `gcc` (tested with version\r\n  4.7.2) are known to successfully compile\r\n- To transpile to JavaScript, you'll need the emscripten toolkit, including\r\n  `emcc`.\r\n- You'll also need `make`\r\n\r\nFirst, clone the repository, and then compile using `make`:\r\n\r\n    $ git clone https://github.com/voithos/awl.git\r\n    $ cd awl\r\n    $ make\r\n\r\nThis will create an `awl` binary under `bin/`.\r\n\r\nYou can also compile and execute tests:\r\n\r\n    $ make test\r\n\r\nOr transpile to JavaScript (`emcc` will need to be in your `$PATH`):\r\n\r\n    $ make web\r\n\r\nYou can also clean up:\r\n\r\n    $ make clean\r\n\r\n## Usage\r\n\r\nThe `awl` binary can take a single argument - a path to a file to execute.\r\n\r\n    $ ./bin/awl [file]\r\n\r\nIf no argument is given, then it will drop into an interactive interpreter\r\n([REPL](http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)):\r\n\r\n    $ ./bin/awl\r\n    awl v0.x.y\r\n    Ctrl+D to exit\r\n\r\n    awl>\r\n\r\n## Features\r\n\r\nAwl is a mini-language that is inspired by the Lisp family of languages. Thus,\r\nit shares most of its features with Lisp and Scheme. These include:\r\n\r\n- Dynamic typing\r\n- First-class functions, including [anonymous (lambda)\r\n  functions](http://en.wikipedia.org/wiki/Anonymous_function)\r\n- Function\r\n  [closures](http://en.wikipedia.org/wiki/Closure_(computer_programming))\r\n- [Partial application](http://en.wikipedia.org/wiki/Partial_application)\r\n- [Tail-call optimization](http://en.wikipedia.org/wiki/Tail_recursion)\r\n- Data immutability (although variables can be redefined currently)\r\n- Lists as the primary data structure\r\n- [Homoiconicity](http://en.wikipedia.org/wiki/Homoiconicity) - that is,\r\n  similar representations of code and data\r\n- Metaprogramming in the form of simple macros\r\n\r\nCurrently, Awl's data definition and manipulation capabilities are lacking, but\r\nthis will hopefully be changed in the future.\r\n\r\n## Language Reference\r\n\r\nAwl is an expression-based language. Basically everything is an expression, and\r\ncan be arbitrarily nested. A program consists of a sequence of such\r\nexpressions.\r\n\r\n### Basic Features\r\n\r\nAwl supports inline comments in the form of Lisp's semicolon `;`:\r\n\r\n    ; Can go on its own line\r\n    (func (plus-one x)\r\n        (+ x 1)) ; Or at the end of a line\r\n\r\nPrinting to standard output can be done using `print` and `println`:\r\n\r\n    awl> (println \"Hello sekai!\")\r\n    Hello sekai!\r\n\r\nVariables are defined with `define` (which is affects the local environment)\r\nand `global` (which, as the name suggests, affects the global environment):\r\n\r\n    awl> (define foo 'bar')\r\n    awl> (println foo)\r\n    bar\r\n\r\n### Primitive Data Types\r\n\r\n<table>\r\n\r\n<thead>\r\n<th>Type</th>\r\n<th>Example</th>\r\n<th>Description</th>\r\n</thead>\r\n\r\n<tbody>\r\n\r\n<tr>\r\n<td>Integer</td>\r\n<td><code>5</code>, <code>-9</code></td>\r\n<td>A standard integer (<code>long</code>)</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>Floating point</td>\r\n<td><code>3.14</code>, <code>-5.</code></td>\r\n<td>A standard floating point (<code>double</code>)</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>Boolean</td>\r\n<td><code>true</code>, <code>false</code></td>\r\n<td>A standard... boolean</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>String</td>\r\n<td><code>'foobar'</code>, <code>\"\\\"escapes\\\" OK\"</code></td>\r\n<td>A string type - either single or double quotes</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>Q-Symbol</td>\r\n<td><code>:like-in-ruby</code>, <code>:foo</code></td>\r\n<td>A quoted symbol (identifier), mostly used in macros</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>Q-Expr</td>\r\n<td><code>{1 'b' (+ 1 2) x y}</code></td>\r\n<td>A quoted expression. The basic data structure - acts like a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>Function</td>\r\n<td><code>(fn (x) (/ 1 x))</code></td>\r\n<td>An anonymous function. The basic mechanism of function definition</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>Error</td>\r\n<td><code>(error 'somebody set up us the bomb')</code></td>\r\n<td>An error. Stops evaluation</td>\r\n</tr>\r\n\r\n</tbody>\r\n\r\n</table>\r\n\r\n### Expressions\r\n\r\nOperations in Awl are defined as\r\n[S-Expressions](http://en.wikipedia.org/wiki/S_expression) (symbolic\r\nexpressions). They are syntactically enclosed in parentheses `()`. The first\r\nargument of the expression must be a callable, and is evaluated in the current\r\nenvironment with any following arguments as parameters (the result is the\r\niconic \"[Polish notation](http://en.wikipedia.org/wiki/Polish_notation)\" of\r\nLisp).\r\n\r\n    awl> (+ 5 6)\r\n    11\r\n    awl> (println 'foo')\r\n    foo\r\n\r\nWhen evaluating user-defined functions, partial application is done\r\nautomatically for any unfilled arguments (this is currently not done for builtins).\r\nThis makes it easy to use higher-order functions quickly:\r\n\r\n    awl> (define xs {1 2 3 4})\r\n    awl> (define square (map (fn (x))))\r\n    awl> (square xs)\r\n    {1 4 9 16}\r\n\r\nVariable and function identifiers, called \"symbols,\" are evaluated to the\r\nvalues that they map to, except in certain special forms (e.g. when they are\r\nbeing defined):\r\n\r\n    awl> (define x 5)\r\n    awl> (+ x 6)\r\n    11\r\n\r\nThe primitive types evaluate to themselves.\r\n\r\nQ-Expressions (quoted expressions, often referred to simply as 'lists') are\r\nparticularly important. They are enclosed inside curly braces `{}`. They are a\r\ncollection type and behave similar to lists. They can store any number and\r\nmixture of primitive types. And they have one more important ability:\r\nexpressions that they contain which would normally be evaluated, such as\r\nsymbols and S-Expressions, are left unevaluated (i.e. they are \"quoted\"). This\r\nallows them to contain arbitrary code, and then be converted and evaluated as\r\nS-Expressions:\r\n\r\n    awl> (head {1 2 3})\r\n    1\r\n    awl> (tail {1 2 3})\r\n    {2 3}\r\n    awl> (define x {* 3 (+ 2 2)})\r\n    awl> x\r\n    {* 3 (+ 2 2)}\r\n    awl> (eval x)\r\n    12\r\n\r\nThere are a few more expression types that are useful in special cases.\r\n\r\nE-Expressions (escaped expressions) are denoted with a preceding backslash `\\`,\r\nand can be used to specifically evaluate a section within a Q-Expression\r\nliteral:\r\n\r\n    awl> {1 2 (+ 2 1)}\r\n    {1 2 (+ 2 1)}\r\n    awl> {1 2 \\(+ 2 1)}\r\n    {1 2 3}\r\n\r\nC-Expressions (concatenating expressions) are denoted with a preceding at-sign\r\n`@`.  They behave similarly to E-Expressions, with the exception that, when\r\ngiven a list (Q-Expression), they \"extract\" the contents and include it\r\ndirectly in the outer list:\r\n\r\n    awl> {1 2 \\{3 4}}\r\n    {1 2 {3 4}}\r\n    awl> {1 2 @{3 4}}\r\n    {1 2 3 4}\r\n\r\n### Builtins\r\n\r\nBuiltins usually behave like normal functions, but they also have the special\r\nrole of enabling some of Awl's basic features, since they are written in C (for\r\nexample, the `fn` builtin creates a new anonymous function).\r\n\r\nAwl makes no distinction between \"operators\" (`+`, `-`, `*`) and other kinds of\r\nbuiltins - they are simply named differently.\r\n\r\n<table>\r\n\r\n<thead>\r\n<th>Builtin</th>\r\n<th>Signature</th>\r\n<th>Description</th>\r\n</thead>\r\n\r\n<tbody>\r\n\r\n<tr>\r\n<td><code>+</code></td>\r\n<td><code>(+ [args...])</code></td>\r\n<td>Addition. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>-</code></td>\r\n<td><code>(- [args...])</code></td>\r\n<td>Subtraction. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>*</code></td>\r\n<td><code>(* [args...])</code></td>\r\n<td>Multiplication. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>/</code></td>\r\n<td><code>(/ [args...])</code></td>\r\n<td>Division. Promotes integers to floats if necessary. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>//</code></td>\r\n<td><code>(// [args...])</code></td>\r\n<td>Truncating division. Removes decimal remainder. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>%</code></td>\r\n<td><code>(% [args...])</code></td>\r\n<td>Modulo. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>^</code></td>\r\n<td><code>(^ [args...])</code></td>\r\n<td>Power operator. Takes 2 or more arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>&gt;</code></td>\r\n<td><code>(&gt; [arg1] [arg2])</code></td>\r\n<td>Greater than. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>&gt;=</code></td>\r\n<td><code>(&gt;= [arg1] [arg2])</code></td>\r\n<td>Greater than or equal to. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>&lt;</code></td>\r\n<td><code>(&lt; [arg1] [arg2])</code></td>\r\n<td>Less than. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>&lt;=</code></td>\r\n<td><code>(&lt;= [arg1] [arg2])</code></td>\r\n<td>Less than or equal to. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>==</code></td>\r\n<td><code>(== [arg1] [arg2])</code></td>\r\n<td>Equal to. Tests deep equality. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>!=</code></td>\r\n<td><code>(!= [arg1] [arg2])</code></td>\r\n<td>Unequal to. Tests deep equality. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>and</code></td>\r\n<td><code>(and [arg1] [arg2])</code></td>\r\n<td>Logical 'and'. Short circuiting. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>or</code></td>\r\n<td><code>(or [arg1] [arg2])</code></td>\r\n<td>Logical 'or'. Short circuiting. Takes 2 arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>not</code></td>\r\n<td><code>(not [arg1])</code></td>\r\n<td>Logical 'not'. Takes 1 argument</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>head</code></td>\r\n<td><code>(head [arg1])</code></td>\r\n<td>Returns the extracted first element (head) of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>qhead</code></td>\r\n<td><code>(qhead [arg1])</code></td>\r\n<td>Like <code>head</code>, except quotes symbols and S-Exprs</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>tail</code></td>\r\n<td><code>(tail [arg1])</code></td>\r\n<td>Returns the tail of a list, excluding the first element</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>first</code></td>\r\n<td><code>(first [arg1])</code></td>\r\n<td>Similar to <code>head</code>, but doesn't extract</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>last</code></td>\r\n<td><code>(last [arg1])</code></td>\r\n<td>Returns the last element of a list, unextracted</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>except-last</code></td>\r\n<td><code>(except-last [arg1])</code></td>\r\n<td>Returns the first section of a list, excluding the last element</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>list</code></td>\r\n<td><code>(list [args...])</code></td>\r\n<td>Returns a list containing the evaluated arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>eval</code></td>\r\n<td><code>(eval [arg1])</code></td>\r\n<td>Evaluates a list as if it were an S-Expression</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>append</code></td>\r\n<td><code>(append [args...])</code></td>\r\n<td>Concatenates two or more lists</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>cons</code></td>\r\n<td><code>(cons [arg1] [arg2])</code></td>\r\n<td>Attaches a primitive type to the head of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>len</code></td>\r\n<td><code>(len [arg1])</code></td>\r\n<td>Returns the length of a collection</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>reverse</code></td>\r\n<td><code>(reverse [arg1])</code></td>\r\n<td>Reverses a collection</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>slice</code></td>\r\n<td><code>(slice [c] [start] [end] [step])</code></td>\r\n<td>Returns a slice of a collection based on start, stop, and step numbers</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>if</code></td>\r\n<td><code>(if [pred] [then-branch] [else-branch])</code></td>\r\n<td>If expression. Evaluates a predicate, and one of two branches based on the result</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>define</code></td>\r\n<td><code>(define [sym] [value])</code></td>\r\n<td>Defines a variable in the local environment</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>global</code></td>\r\n<td><code>(global [sym] [value])</code></td>\r\n<td>Defines a variable in the global environment</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>let</code></td>\r\n<td><code>(let (([sym1] [val1])...) [expr])</code></td>\r\n<td>Creates a local environment and defines variables within</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>fn</code></td>\r\n<td><code>(fn ([args...]) [body])</code></td>\r\n<td>Defines an anonymous function with the specified arguments and body. The\r\nfunction also retains the current environment as a closure</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>macro</code></td>\r\n<td><code>(macro [name] ([args...]) [body])</code></td>\r\n<td>Defines a macro that can operate on code before it is evaluated</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>typeof</code></td>\r\n<td><code>(typeof [arg1])</code></td>\r\n<td>Returns a string representing the type of the argument</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>import</code></td>\r\n<td><code>(import [path])</code></td>\r\n<td>Attempts to import the <code>awl</code> file at the given path</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>print</code></td>\r\n<td><code>(print [arg1])</code></td>\r\n<td>Prints to standard output</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>println</code></td>\r\n<td><code>(println [arg1])</code></td>\r\n<td>Prints to standard output, adding a newline</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>error</code></td>\r\n<td><code>(error [arg1])</code></td>\r\n<td>  </td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>exit</code></td>\r\n<td><code>(exit [arg1])</code></td>\r\n<td>Exits the interactive REPL</td>\r\n</tr>\r\n\r\n</tbody>\r\n\r\n</table>\r\n\r\n### Core Library\r\n\r\nIn addition to builtins, there exists a core library that Awl imports on\r\nstartup. Among other things, this library aims to exercise some of Awl's\r\nfeatures, as well as provide some basic functional tools.\r\n\r\n<table>\r\n\r\n<thead>\r\n<th>Symbol</th>\r\n<th>Signature</th>\r\n<th>Description</th>\r\n</thead>\r\n\r\n<tbody>\r\n\r\n<tr>\r\n<td><code>nil</code></td>\r\n<td></td>\r\n<td>Alias for <code>{}</code></td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>func</code></td>\r\n<td><code>(func ([name] [args]) [body])</code></td>\r\n<td>Macro that defines a named function</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>int?</code></td>\r\n<td><code>(int? [arg1])</code></td>\r\n<td>Checks that argument is an integer</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>float?</code></td>\r\n<td><code>(float? [arg1])</code></td>\r\n<td>Checks that argument is a floating point</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>string?</code></td>\r\n<td><code>(string? [arg1])</code></td>\r\n<td>Checks that argument is a string</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>fn?</code></td>\r\n<td><code>(fn? [arg1])</code></td>\r\n<td>Checks that argument is a function</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>bool?</code></td>\r\n<td><code>(bool? [arg1])</code></td>\r\n<td>Checks that argument is a boolean</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>qexpr?</code></td>\r\n<td><code>(qexpr? [arg1])</code></td>\r\n<td>Checks that argument is a Q-Expression</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>list?</code></td>\r\n<td><code>(list? [arg1])</code></td>\r\n<td>Alias for <code>qexpr?</code></td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>nil?</code></td>\r\n<td><code>(nil? [arg1])</code></td>\r\n<td>Checks that argument is <code>nil</code></td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>do</code></td>\r\n<td><code>(do [expr1] [expr2] ... [exprn])</code></td>\r\n<td>Evaluates its arguments one by one, and returns the result of the last\r\nargument</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>compose</code></td>\r\n<td><code>(compose [f] [g] [xs...])</code></td>\r\n<td>Composes two functions</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>flip</code></td>\r\n<td><code>(flip [f] [x] [y])</code></td>\r\n<td>Takes a function and two argument, and flip the ordering of the arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>reduce</code></td>\r\n<td><code>(reduce [f] [l] [acc])</code></td>\r\n<td>Reduces a list to a single value using a reducer function</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>reduce-left</code></td>\r\n<td><code>(reduce-left [f] [l] [acc])</code></td>\r\n<td>Like <code>reduce</code>, but traverses the list in the opposite direction</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>map</code></td>\r\n<td><code>(map [f] [l])</code></td>\r\n<td>Applies a function to each element of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>filter</code></td>\r\n<td><code>(filter [f] [l])</code></td>\r\n<td>Uses a predicate function to filter out elements from a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>sum</code></td>\r\n<td><code>(sum [l])</code></td>\r\n<td>Sums elements of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>product</code></td>\r\n<td><code>(product [l])</code></td>\r\n<td>Multiplies together elements of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>pack</code></td>\r\n<td><code>(pack [f] [args...])</code></td>\r\n<td>Takes multiple argument and feeds it to a function as a single list\r\nargument</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>unpack</code></td>\r\n<td><code>(unpack [f] [l])</code></td>\r\n<td>Evaluates a function using a list of arguments</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>nth</code></td>\r\n<td><code>(nth [n] [l])</code></td>\r\n<td>Returns the <code>nth</code> element of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>take</code></td>\r\n<td><code>(take [n] [l])</code></td>\r\n<td>Takes the first <code>n</code> elements of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>drop</code></td>\r\n<td><code>(drop [n] [l])</code></td>\r\n<td>Drops the first <code>n</code> elements of a list, returning what's\r\nleft</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>member?</code></td>\r\n<td><code>(member? [x] [l])</code></td>\r\n<td>Checks if an element is a member of a list</td>\r\n</tr>\r\n\r\n<tr>\r\n<td><code>range</code></td>\r\n<td><code>(range [s] [e])</code></td>\r\n<td>Returns a list of integers starting with <code>s</code> and going up to\r\n<code>e</code></td>\r\n</tr>\r\n\r\n</tbody>\r\n\r\n</table>\r\n\r\n## Open Source\r\n\r\nMany thanks goes to the following awesome libraries and open source projects,\r\nand their creators:\r\n\r\n- mpc.c\r\n- ptest.c\r\n- linenoise\r\n- clang / LLVM\r\n- emscripten\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}