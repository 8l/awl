;; Awl core library
;;

; Global definitions
(global nil {})
(global else true)

; System macros
(macro func (f b)
    {global @(first (qhead f)) (fn (@(tail (qhead f))) @b)})

; Type functions
(func (int? x) (== (typeof x) 'integer'))
(func (float? x) (== (typeof x) 'float'))
(func (string? x) (== (typeof x) 'string'))
(func (fn? x) (== (typeof x) 'function'))
(func (bool? x) (== (typeof x) 'boolean'))
(func (qexpr? x) (== (typeof x) 'qexpr'))
(global list? qexpr?)

(func (nil? x) (== x nil))

; Basic control structures
(func (do & l)
    (if (nil? l)
        nil
        (head (last l))))

; Higher-order functions
(func (compose f g & x)
      (f (g x)))

(func (flip f x y)
      (f y x))

(func (reduce f l acc)
    (if (nil? l)
        acc
        (f (reduce f (tail l) acc) (head l))))

(func (reduce-left f l acc)
    (if (nil? l)
        acc
        (reduce-left f (tail l) (f acc (head l)))))

(func (map f l)
    (reduce (fn (acc v)
                (cons (f v) acc)) l nil))

(func (filter f l)
    (reduce (fn (acc v)
                (if (f v)
                    (cons v acc)
                    acc)) l nil))

(func (sum l)
      (reduce + l 0))

(func (product l)
      (reduce * l 1))

; List functions
(func (pack f & xs)
      (f xs))

(func (unpack f xs)
      (eval (cons f xs)))

(func (nth n l)
      (let ((s (slice l n (+ n 1))))
            (if (nil? s)
                s
                (head s))))

(func (take n l)
      (slice l 0 n))

(func (drop n l)
      (slice l n))

(func (member? x l)
      (if (nil? l)
          false
          (if (== x (head l))
              true
              (member? x (tail l)))))

(func (range s e)
      (if (>= s e)
          nil
          (cons s (range (+ s 1) e))))
