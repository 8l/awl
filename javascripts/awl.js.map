{"version":3,"file":"web/awl.js","sources":["src/awl.c","src/builtins.c","/home/zaven/Projects/Programming/External/emscripten/system/include/libc/math.h","src/eval.c","src/mpc.c","src/parser.c","src/print.c","src/repl.c","src/types.c","src/util.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AACA;AACA;AACA;;;;;AAGA;AACA;;;;;AAGA;;;;;;;;;;AC+BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAuFA;AAAA;;AArFA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AADA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoFA;AAAA;;AAjFA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AASA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;AACA;AAAA;;;;;;;;;AAGA;AAAA;AACA;AAAA;;;;AAKA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAFA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAMA;AAAA;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAA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AAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAFA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAMA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;AASA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAOA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAMA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AASA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;;;;;;;;;;AAvaA;AAAA;AAEA;AAA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AAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAYA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAieA;;;;;;;;;;AA7dA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;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;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA8DA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2JA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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","sourcesContent":["#include \"awl.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <time.h>\n\n#include \"assert.h\"\n#include \"builtins.h\"\n#include \"parser.h\"\n#include \"print.h\"\n#include \"util.h\"\n\nvoid run_scripts(awlenv* e, int argc, char** argv) {\n    for (int i = 1; i < argc; i++) {\n        awlval* args = awlval_add(awlval_sexpr(), awlval_str(argv[i]));\n        awlval* x = builtin_import(e, args);\n\n        if (x->type == AWLVAL_ERR) {\n            awlval_println(x);\n        }\n        awlval_del(x);\n    }\n}\n\nvoid setup_awl(void) {\n    srand(time(NULL));\n    register_default_print_fn();\n    setup_parser();\n}\n\nvoid teardown_awl(void) {\n    teardown_parser();\n}\n\nchar* get_awl_version(void) {\n    return AWL_VERSION;\n}\n","#include \"builtins.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <signal.h>\n#include <string.h>\n#include <math.h>\n#include <sys/stat.h>\n\n#include \"assert.h\"\n#include \"eval.h\"\n#include \"parser.h\"\n#include \"print.h\"\n#include \"repl.h\"\n#include \"util.h\"\n\n#define UNARY_OP(a, op) { \\\n    switch (a->type) { \\\n        case AWLVAL_INT: \\\n            a->lng = op a->lng; \\\n            break; \\\n        case AWLVAL_FLOAT: \\\n            a->dbl = op a->dbl; \\\n            break; \\\n        default: break; \\\n    } \\\n}\n\n#define BINARY_OP(a, b, op) { \\\n    switch (a->type) { \\\n        case AWLVAL_INT: \\\n            a->lng = a->lng op b->lng; \\\n            break; \\\n        case AWLVAL_FLOAT: \\\n            a->dbl = a->dbl op b->dbl; \\\n            break; \\\n        default: break; \\\n    } \\\n}\n\n#define BINARY_OP_RES(res, a, b, op) { \\\n    switch (a->type) { \\\n        case AWLVAL_INT: \\\n            res = a->lng op b->lng; \\\n            break; \\\n        case AWLVAL_FLOAT: \\\n            res = a->dbl op b->dbl; \\\n            break; \\\n        default: break; \\\n    } \\\n}\n\n#define BINARY_OP_FUNC(a, b, func) { \\\n    switch (a->type) { \\\n        case AWLVAL_INT: \\\n            a->lng = func (a->lng, b->lng); \\\n            break; \\\n        case AWLVAL_FLOAT: \\\n            a->dbl = func (a->dbl, b->dbl); \\\n            break; \\\n        default: break; \\\n    } \\\n}\n\nlong modulo(long x, long y) {\n    /* Modulo operator, always positive */\n    return labs(x) % labs(y);\n}\n\ndouble fmodulo(double x, double y) {\n    /* Modulo operator, always positive */\n    return fmod(fabs(x), fabs(y));\n}\n\nawlval* builtin_num_op(awlenv* e, awlval* a, char* op) {\n    /* Argcount must be checked in calling function, because\n     * different operators have different requirements */\n    EVAL_ARGS(e, a);\n\n    for (int i = 0; i < a->count; i++) {\n        AWLASSERT_ISNUMERIC(a, i, op);\n    }\n\n    awlval* x = awlval_pop(a, 0);\n    if (streq(op, \"-\") && a->count == 0) {\n        UNARY_OP(x, -);\n    }\n\n    while (a->count > 0) {\n        awlval* y = awlval_pop(a, 0);\n\n        awlval_maybe_promote_numeric(x, y);\n\n        if (streq(op, \"+\")) { BINARY_OP(x, y, +); }\n        if (streq(op, \"-\")) { BINARY_OP(x, y, -); }\n        if (streq(op, \"*\")) { BINARY_OP(x, y, *); }\n        if (streq(op, \"/\") || streq(op, \"//\") || streq(op, \"%\")) {\n            /* Handle division or modulo by zero */\n            if ((y->type == AWLVAL_INT && y->lng == 0) ||\n                (y->type == AWLVAL_FLOAT && y->dbl == 0)) {\n                awlval* err = awlval_err(\"division by zero; %i %s 0\", x->lng, op);\n                awlval_del(x);\n                awlval_del(y);\n                x = err;\n                break;\n            }\n\n            if (strstr(op, \"/\")) {\n                awlval_type_t oldtype_x = x->type;\n                awlval_type_t oldtype_y = y->type;\n\n                /* Handle fractional integer division */\n                if (x->type == AWLVAL_INT && y->type == AWLVAL_INT && x->lng % y->lng != 0) {\n                    awlval_promote_numeric(x);\n                    awlval_promote_numeric(y);\n                }\n\n                BINARY_OP(x, y, /);\n\n                if (streq(op, \"//\")) {\n                    /* Truncating division, based on old types */\n                    if (oldtype_x == AWLVAL_INT && oldtype_y == AWLVAL_INT) {\n                        awlval_demote_numeric(x);\n                    } else {\n                        /* Truncate, but we still need to keep result a float */\n                        awlval_demote_numeric(x);\n                        awlval_promote_numeric(x);\n                    }\n                }\n            } else {\n                /* Handle modulo */\n                if (x->type == AWLVAL_FLOAT || y->type == AWLVAL_FLOAT) {\n                    BINARY_OP_FUNC(x, y, fmodulo);\n                } else {\n                    x->lng = modulo(x->lng, y->lng);\n                }\n            }\n        }\n        if (streq(op, \"^\")) {\n            if (x->type == AWLVAL_FLOAT || y->type == AWLVAL_FLOAT) {\n                BINARY_OP_FUNC(x, y, pow);\n            } else {\n                /* Handle case where result is fractional */\n                double ans = pow((double)x->lng, y->lng);\n                if (ans - (double)(long)ans != 0.0) {\n                    x->type = AWLVAL_FLOAT;\n                    x->dbl = ans;\n                } else {\n                    x->lng = (long)ans;\n                }\n            }\n\n            // Check for NaN\n            if (x->type == AWLVAL_FLOAT && isnan(x->dbl)) {\n                awlval_del(x);\n                x = awlval_err(\"pow resulted in NaN\");\n            }\n        }\n\n        awlval_del(y);\n    }\n\n    awlval_del(a);\n    return x;\n}\n\nawlval* builtin_add(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"+\");\n    return builtin_num_op(e, a, \"+\");\n}\n\nawlval* builtin_sub(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 1, \"-\");\n    return builtin_num_op(e, a, \"-\");\n}\n\nawlval* builtin_mul(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"*\");\n    return builtin_num_op(e, a, \"*\");\n}\n\nawlval* builtin_div(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"/\");\n    return builtin_num_op(e, a, \"/\");\n}\n\nawlval* builtin_trunc_div(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"//\");\n    return builtin_num_op(e, a, \"//\");\n}\n\nawlval* builtin_mod(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"%\");\n    return builtin_num_op(e, a, \"%\");\n}\n\nawlval* builtin_pow(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"^\");\n    return builtin_num_op(e, a, \"^\");\n}\n\nawlval* builtin_ord_op(awlenv* e, awlval* a, char* op) {\n    AWLASSERT_ARGCOUNT(a, 2, op);\n    EVAL_ARGS(e, a);\n    AWLASSERT_ISNUMERIC(a, 0, op);\n    AWLASSERT_ISNUMERIC(a, 1, op);\n\n    awlval* x = awlval_pop(a, 0);\n    awlval* y = awlval_pop(a, 0);\n\n    awlval_maybe_promote_numeric(x, y);\n\n    bool res;\n    if (streq(op, \">\")) {\n        BINARY_OP_RES(res, x, y, >);\n    }\n    if (streq(op, \"<\")) {\n        BINARY_OP_RES(res, x, y, <);\n    }\n    if (streq(op, \">=\")) {\n        BINARY_OP_RES(res, x, y, >=);\n    }\n    if (streq(op, \"<=\")) {\n        BINARY_OP_RES(res, x, y, <=);\n    }\n\n    awlval_del(y);\n    awlval_del(a);\n\n    x->type = AWLVAL_BOOL;\n    x->bln = res;\n    return x;\n}\n\nawlval* builtin_gt(awlenv* e, awlval* a) {\n    return builtin_ord_op(e, a, \">\");\n}\n\nawlval* builtin_gte(awlenv* e, awlval* a) {\n    return builtin_ord_op(e, a, \">=\");\n}\n\nawlval* builtin_lt(awlenv* e, awlval* a) {\n    return builtin_ord_op(e, a, \"<\");\n}\n\nawlval* builtin_lte(awlenv* e, awlval* a) {\n    return builtin_ord_op(e, a, \"<=\");\n}\n\nawlval* builtin_logic_op(awlenv* e, awlval* a, char* op) {\n    AWLASSERT_ARGCOUNT(a, 2, op);\n    EVAL_ARGS(e, a);\n\n    bool eq = awlval_eq(a->cell[0], a->cell[1]);\n    bool res;\n    if (streq(op, \"==\")) {\n        res = eq;\n    }\n    if (streq(op, \"!=\")) {\n        res = !eq;\n    }\n    awlval_del(a);\n    return awlval_bool(res);\n}\n\nawlval* builtin_eq(awlenv* e, awlval* a) {\n    return builtin_logic_op(e, a, \"==\");\n}\n\nawlval* builtin_neq(awlenv* e, awlval* a) {\n    return builtin_logic_op(e, a, \"!=\");\n}\n\nawlval* builtin_bool_op(awlenv* e, awlval* a, char* op) {\n    if (streq(op, \"not\")) {\n        AWLASSERT_ARGCOUNT(a, 1, op);\n        EVAL_SINGLE_ARG(e, a, 0);\n        AWLASSERT_TYPE(a, 0, AWLVAL_BOOL, op);\n\n        awlval* x = awlval_take(a, 0);\n        x->bln = !x->bln;\n        return x;\n    }\n\n    AWLASSERT_ARGCOUNT(a, 2, op);\n\n    awlval* x = awlval_pop(a, 0);\n    awlval* y = awlval_take(a, 0);\n\n    x = awlval_eval(e, x);\n    if (x->type != AWLVAL_BOOL) {\n        awlval* err = awlval_err(\n                \"function '%s' passed incorrect type for arg %i; got %s, expected %s\",\n                op, 0, awlval_type_name(x->type), awlval_type_name(AWLVAL_BOOL));\n        awlval_del(x);\n        awlval_del(y);\n        return err;\n    }\n\n    if ((streq(op, \"and\") && !x->bln) || (streq(op, \"or\") && x->bln)) {\n        awlval_del(y);\n        return x;\n    }\n\n    y = awlval_eval(e, y);\n    if (y->type != AWLVAL_BOOL) {\n        awlval* err = awlval_err(\n                \"function '%s' passed incorrect type for arg %i; got %s, expected %s\",\n                op, 1, awlval_type_name(y->type), awlval_type_name(AWLVAL_BOOL));\n        awlval_del(x);\n        awlval_del(y);\n        return err;\n    }\n\n    if (streq(op, \"and\")) {\n        x->bln = x->bln && y->bln;\n    }\n    if (streq(op, \"or\")) {\n        x->bln = x->bln || y->bln;\n    }\n\n    awlval_del(y);\n    return x;\n}\n\nawlval* builtin_and(awlenv* e, awlval* a) {\n    return builtin_bool_op(e, a, \"and\");\n}\n\nawlval* builtin_or(awlenv* e, awlval* a) {\n    return builtin_bool_op(e, a, \"or\");\n}\n\nawlval* builtin_not(awlenv* e, awlval* a) {\n    return builtin_bool_op(e, a, \"not\");\n}\n\nawlval* builtin_head(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"head\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"head\");\n    AWLASSERT_NONEMPTY(a, a->cell[0], \"head\");\n\n    awlval* v = awlval_take(a, 0);\n    return awlval_eval(e, awlval_take(v, 0));\n}\n\nawlval* builtin_qhead(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"qhead\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"qhead\");\n    AWLASSERT_NONEMPTY(a, a->cell[0], \"qhead\");\n\n    awlval* q = awlval_take(a, 0);\n    awlval* v = awlval_take(q, 0);\n\n    if (v->type == AWLVAL_SEXPR) {\n        v->type = AWLVAL_QEXPR;\n    } else if (v->type == AWLVAL_SYM) {\n        v->type = AWLVAL_QSYM;\n    }\n    return awlval_eval(e, v);\n}\n\nawlval* builtin_tail(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"tail\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"tail\");\n    AWLASSERT_NONEMPTY(a, a->cell[0], \"tail\");\n\n    awlval* v = awlval_take(a, 0);\n    return awlval_slice(v, 1, v->count);\n}\n\nawlval* builtin_first(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"first\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"first\");\n    AWLASSERT_NONEMPTY(a, a->cell[0], \"first\");\n\n    awlval* v = awlval_take(a, 0);\n    return awlval_slice(v, 0, 1);\n}\n\nawlval* builtin_last(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"last\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"last\");\n    AWLASSERT_NONEMPTY(a, a->cell[0], \"last\");\n\n    awlval* v = awlval_take(a, 0);\n    return awlval_slice(v, v->count - 1, v->count);\n}\n\nawlval* builtin_exceptlast(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"except-last\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"except-last\");\n    AWLASSERT_NONEMPTY(a, a->cell[0], \"except-last\");\n\n    awlval* v = awlval_take(a, 0);\n    return awlval_slice(v, 0, v->count - 1);\n}\n\nawlval* builtin_list(awlenv* e, awlval* a) {\n    EVAL_ARGS(e, a);\n\n    a->type = AWLVAL_QEXPR;\n    return a;\n}\n\nawlval* builtin_eval(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"eval\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QEXPR, \"eval\");\n\n    awlval* x = awlval_take(a, 0);\n    x->type = AWLVAL_SEXPR;\n    return awlval_eval(e, x);\n}\n\nawlval* builtin_append(awlenv* e, awlval* a) {\n    AWLASSERT_MINARGCOUNT(a, 2, \"append\");\n    EVAL_ARGS(e, a);\n\n    for (int i = 0; i < a->count; i++) {\n        AWLASSERT_TYPE(a, i, AWLVAL_QEXPR, \"append\");\n    }\n\n    awlval* x = awlval_pop(a, 0);\n    while (a->count) {\n        x = awlval_join(x, awlval_pop(a, 0));\n    }\n\n    awlval_del(a);\n    return x;\n}\n\nawlval* builtin_cons(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 2, \"cons\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 1, AWLVAL_QEXPR, \"cons\");\n\n    awlval* v = awlval_pop(a, 0);\n    awlval* x = awlval_take(a, 0);\n    awlval_add_front(x, v);\n    return x;\n}\n\nawlval* builtin_len(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"len\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_ISCOLLECTION(a, 0, \"len\");\n\n    awlval* x = awlval_int(a->cell[0]->length);\n    awlval_del(a);\n    return x;\n}\n\nawlval* builtin_reverse(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"reverse\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_ISCOLLECTION(a, 0, \"reverse\");\n\n    awlval* collection = awlval_take(a, 0);\n\n    return awlval_reverse(collection);\n}\n\nawlval* builtin_slice(awlenv* e, awlval* a) {\n    AWLASSERT_RANGEARGCOUNT(a, 2, 4, \"slice\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_ISCOLLECTION(a, 0, \"slice\");\n    AWLASSERT_TYPE(a, 1, AWLVAL_INT, \"slice\");\n\n    bool end_arg_given = a->count > 2;\n    if (end_arg_given) {\n        AWLASSERT_TYPE(a, 2, AWLVAL_INT, \"slice\");\n    }\n\n    bool step_arg_given = a->count > 3;\n    if (step_arg_given) {\n        AWLASSERT_TYPE(a, 3, AWLVAL_INT, \"slice\");\n        AWLASSERT_NONZERO(a, (int)a->cell[3]->lng, \"slice\");\n    }\n\n    awlval* collection = awlval_pop(a, 0);\n\n    int start, end, step;\n    bool reverse_slice = false;\n\n    /* TODO: Index cast is unsafe here */\n    start = (int)a->cell[0]->lng;\n    end = end_arg_given ? (int)a->cell[1]->lng : collection->length;\n    step = step_arg_given ? (int)a->cell[2]->lng : 1;\n\n    awlval_del(a);\n\n    /* Support negative indices to represent index from end */\n    if (start < 0) {\n        start = collection->length + start;\n    }\n    if (end < 0) {\n        end = collection->length + end;\n    }\n\n    /* Handle negative step */\n    if (step < 0) {\n        step = -step;\n        int temp = start;\n        start = end;\n        end = temp;\n    }\n\n    if (end < start) {\n        reverse_slice = true;\n        int temp = start + 1;\n        start = end + 1;\n        end = temp;\n    }\n\n    /* Constrain to collection bounds */\n    start = start < 0 ? 0 :\n        (start > collection->length ? collection->length : start);\n    end = end < 0 ? 0 :\n        (end > collection->length ? collection->length : end);\n\n    collection = awlval_slice_step(collection, start, end, step);\n    return reverse_slice ? awlval_reverse(collection) : collection;\n}\n\nawlval* builtin_if(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 3, \"if\");\n\n    EVAL_SINGLE_ARG(e, a, 0);\n    AWLASSERT_TYPE(a, 0, AWLVAL_BOOL, \"if\");\n\n    awlval* x;\n    /* does not eval result; sends it back to awlval_eval for\n     * potential tail call optimization */\n    if (a->cell[0]->bln) {\n        x = awlval_pop(a, 1);\n    } else {\n        x = awlval_pop(a, 2);\n    }\n\n    awlval_del(a);\n    return x;\n}\n\nawlval* builtin_var(awlenv* e, awlval* a, bool global) {\n    char* op = global ? \"global\" : \"define\";\n    AWLASSERT_MINARGCOUNT(a, 2, op);\n\n    /* Special case when there is a single symbol to be defined */\n    if (a->cell[0]->type == AWLVAL_SYM) {\n        AWLASSERT_ARGCOUNT(a, 2, op);\n\n        int index = awlenv_index(e, a->cell[0]);\n        if (index != -1) {\n            AWLASSERT(a, !(e->locked[index]),\n                    \"cannot redefine builtin function '%s'\", e->syms[index]);\n        }\n\n        EVAL_SINGLE_ARG(e, a, 1);\n\n        if (global) {\n            awlenv_put_global(e, a->cell[0], a->cell[1], false);\n        } else {\n            awlenv_put(e, a->cell[0], a->cell[1], false);\n        }\n        awlval_del(a);\n        return awlval_qexpr();\n    }\n\n    AWLASSERT_TYPE(a, 0, AWLVAL_SEXPR, op);\n\n    awlval* syms = a->cell[0];\n    for (int i = 0; i < syms->count; i++) {\n        AWLASSERT(a, (syms->cell[i]->type == AWLVAL_SYM),\n                \"function '%s' cannot define non-symbol at position %i\", op, i);\n    }\n\n    for (int i = 0; i < syms->count; i++) {\n        int index = awlenv_index(e, syms->cell[i]);\n        if (index != -1) {\n            AWLASSERT(a, !(e->locked[index]),\n                    \"cannot redefine builtin function '%s'\", e->syms[index]);\n        }\n    }\n\n    AWLASSERT(a, (syms->count == a->count - 1),\n            \"function '%s' given non-matching number of symbols and values; %i symbols, %i values\",\n            op, syms->count, a->count - 1);\n\n    /* Evaluate value arguments (but not the symbols) */\n    for (int i = 1; i < a->count; i++) {\n        EVAL_SINGLE_ARG(e, a, i);\n    }\n\n    for (int i = 0; i < syms->count; i++) {\n        if (global) {\n            awlenv_put_global(e, syms->cell[i], a->cell[i + 1], false);\n        } else {\n            awlenv_put(e, syms->cell[i], a->cell[i + 1], false);\n        }\n    }\n\n    awlval_del(a);\n    return awlval_qexpr();\n}\n\nawlval* builtin_define(awlenv* e, awlval* a) {\n    return builtin_var(e, a, false);\n}\n\nawlval* builtin_global(awlenv* e, awlval* a) {\n    return builtin_var(e, a, true);\n}\n\nawlval* builtin_let(awlenv* e, awlval* a) {\n    /* TODO: maybe fix DEFINE and GLOBAL to work like this too... */\n    AWLASSERT_ARGCOUNT(a, 2, \"let\");\n    AWLASSERT_TYPE(a, 0, AWLVAL_SEXPR, \"let\");\n\n    awlval* bindings = a->cell[0];\n    /* verify structure of inner bindings list */\n    for (int i = 0; i < bindings->count; i++) {\n        AWLASSERT(a, (bindings->cell[i]->type == AWLVAL_SEXPR),\n                \"function '%s' requires %s in binding list at position %i\",\n                \"let\", awlval_type_name(AWLVAL_SEXPR), i);\n\n        AWLASSERT(a, (bindings->cell[i]->count == 2 && bindings->cell[i]->cell[0]->type == AWLVAL_SYM),\n                \"function '%s' bindings must have two parts: %s and value, at position %i\",\n                \"let\", awlval_type_name(AWLVAL_SYM), i);\n    }\n\n    for (int i = 0; i < bindings->count; i++) {\n        int index = awlenv_index(e, bindings->cell[i]->cell[0]);\n        if (index != -1) {\n            AWLASSERT(a, !(e->locked[index]),\n                    \"cannot redefine builtin function '%s'\", e->syms[index]);\n        }\n    }\n\n    awlenv* lenv = awlenv_new();\n    lenv->parent = e;\n\n    /* Evaluate value arguments (but not the symbols) */\n    for (int i = 0; i < bindings->count; i++) {\n        bindings->cell[i] = awlval_eval_arg(lenv, bindings->cell[i], 1);\n\n        if (bindings->cell[i]->type == AWLVAL_ERR) {\n            awlval* err = awlval_pop(bindings, i);\n            awlval_del(a);\n            lenv->parent = NULL;\n            awlenv_del(lenv);\n            return err;\n        }\n\n        awlenv_put(lenv, bindings->cell[i]->cell[0], bindings->cell[i]->cell[1], false);\n    }\n\n    awlval* v = awlval_eval(lenv, awlval_take(a, 1));\n\n    lenv->parent = NULL;\n    awlenv_del(lenv);\n    return v;\n}\n\nawlval* builtin_lambda(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 2, \"fn\");\n    AWLASSERT_ISEXPR(a, 0, \"fn\");\n\n    for (int i = 0; i < a->cell[0]->count; i++) {\n        AWLASSERT(a, (a->cell[0]->cell[i]->type == AWLVAL_SYM),\n                \"function 'fn' cannot take non-symbol argument at position %i\", i);\n    }\n\n    awlval* formals = awlval_pop(a, 0);\n    awlval* body = awlval_take(a, 0);\n    return awlval_lambda(e, formals, body);\n}\n\nawlval* builtin_macro(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 3, \"macro\");\n    AWLASSERT_TYPE(a, 0, AWLVAL_SYM, \"macro\");\n    AWLASSERT_ISEXPR(a, 1, \"macro\");\n\n    int index = awlenv_index(e, a->cell[0]);\n    if (index != -1) {\n        AWLASSERT(a, !(e->locked[index]),\n                \"cannot redefine builtin function '%s'\", e->syms[index]);\n    }\n\n    for (int i = 0; i < a->cell[1]->count; i++) {\n        AWLASSERT(a, (a->cell[1]->cell[i]->type == AWLVAL_SYM),\n                \"macro cannot take non-symbol argument at position %i\", i);\n    }\n\n    awlval* name = awlval_pop(a, 0);\n    awlval* formals = awlval_pop(a, 0);\n    awlval* body = awlval_take(a, 0);\n\n    awlval* macro = awlval_macro(e, formals, body);\n\n    awlenv_put(e, name, macro, false);\n\n    awlval_del(name);\n    awlval_del(macro);\n    return awlval_qexpr();\n}\n\nawlval* builtin_typeof(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"typeof\");\n    EVAL_ARGS(e, a);\n\n    awlval* arg = awlval_take(a, 0);\n    awlval* res = awlval_qsym(awlval_type_sysname(arg->type));\n    awlval_del(arg);\n    return res;\n}\n\nawlval* builtin_convert(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 2, \"convert\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_QSYM, \"convert\");\n\n    awlval* tsym = awlval_pop(a, 0);\n    awlval* v = awlval_take(a, 0);\n\n    awlval* res;\n    awlval_type_t type = awlval_parse_sysname(tsym->sym);\n    if (errno != EINVAL) {\n        res = awlval_convert(type, v);\n    } else {\n        res = awlval_err(\"no such type: %s\", tsym->sym);\n    }\n\n    awlval_del(tsym);\n    awlval_del(v);\n\n    return res;\n}\n\nawlval* builtin_import(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"import\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_STR, \"import\");\n\n    // Check the import path\n    char* importPath = malloc(strlen(a->cell[0]->str) + 5); // extra space for extension\n    strcpy(importPath, a->cell[0]->str);\n    strcat(importPath, \".awl\");\n\n    // Attempt twice: once with the .awl extension, and once with the raw path\n    for (int attempt = 0; attempt < 2; attempt++) {\n        struct stat s;\n        errno = 0;\n        int statErr = stat(importPath, &s);\n\n        bool hasError = statErr || !S_ISREG(s.st_mode);\n\n        // Keep going if we've successfully found a file\n        if (!hasError) {\n            break;\n        } else {\n            free(importPath);\n\n            // Try the raw path if we have once more attempt\n            if (attempt == 0) {\n                importPath = malloc(strlen(a->cell[0]->str) + 1);\n                strcpy(importPath, a->cell[0]->str);\n            } else {\n                // Return error otherwise\n                awlval* errval;\n                if (statErr && errno == ENOENT) {\n                    errval = awlval_err(\"path '%s' does not exist\", a->cell[0]->str);\n                } else if (!S_ISREG(s.st_mode)) {\n                    errval = awlval_err(\"path '%s' is not a regular file\", a->cell[0]->str);\n                } else {\n                    errval = awlval_err(\"unknown import error\");\n                }\n                awlval_del(a);\n                return errval;\n            }\n        }\n    }\n\n    awlval* v;\n    char* err;\n    if (awlval_parse_file(importPath, &v, &err)) {\n        free(importPath);\n\n        while (v->count) {\n            awlval* x = awlval_eval(e, awlval_pop(v, 0));\n            if (x->type == AWLVAL_ERR) {\n                awlval_println(x);\n            }\n            awlval_del(x);\n        }\n\n        awlval_del(v);\n        awlval_del(a);\n\n        return awlval_qexpr();\n    } else {\n        free(importPath);\n\n        awlval* errval = awlval_err(\"could not import %s\", err);\n        free(err);\n        awlval_del(a);\n\n        return errval;\n    }\n}\n\nawlval* builtin_print(awlenv* e, awlval* a) {\n    EVAL_ARGS(e, a);\n    for (int i = 0; i < a->count; i++) {\n        if (i != 0) {\n            awl_printf(\" \");\n        }\n        if (a->cell[i]->type == AWLVAL_STR) {\n            awl_printf(\"%s\", a->cell[i]->str);\n        } else {\n            awlval_print(a->cell[i]);\n        }\n    }\n    awlval_del(a);\n    return awlval_qexpr();\n}\n\nawlval* builtin_println(awlenv* e, awlval* a) {\n    awlval* x = builtin_print(e, a);\n    awl_printf(\"\\n\");\n    return x;\n}\n\nawlval* builtin_random(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 0, \"random\");\n    double r = (double)rand() / (double)RAND_MAX;\n    return awlval_float(r);\n}\n\nawlval* builtin_error(awlenv* e, awlval* a) {\n    AWLASSERT_ARGCOUNT(a, 1, \"error\");\n    EVAL_ARGS(e, a);\n    AWLASSERT_TYPE(a, 0, AWLVAL_STR, \"error\");\n\n    awlval* err = awlval_err(a->cell[0]->str);\n    awlval_del(a);\n    return err;\n}\n\nawlval* builtin_exit(awlenv* e, awlval* a) {\n    awlval_del(a);\n    abort_repl();\n    return awlval_qexpr();\n}\n","#ifndef _MATH_H\n#define _MATH_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <features.h>\n\n#define __NEED_float_t\n#define __NEED_double_t\n#include <bits/alltypes.h>\n\n#if 100*__GNUC__+__GNUC_MINOR__ >= 303\n#define NAN       __builtin_nanf(\"\")\n#define INFINITY  __builtin_inff()\n#else\n#define NAN       (0.0f/0.0f)\n#define INFINITY  1e40f\n#endif\n\n#define HUGE_VALF INFINITY\n#define HUGE_VAL  ((double)INFINITY)\n#define HUGE_VALL ((long double)INFINITY)\n\n#define MATH_ERRNO  1\n#define MATH_ERREXCEPT 2\n#define math_errhandling 2\n\n#define FP_ILOGBNAN (-1-(int)(((unsigned)-1)>>1))\n#define FP_ILOGB0 FP_ILOGBNAN\n\n#define FP_NAN       0\n#define FP_INFINITE  1\n#define FP_ZERO      2\n#define FP_SUBNORMAL 3\n#define FP_NORMAL    4\n\nint __fpclassify(double);\nint __fpclassifyf(float);\nint __fpclassifyl(long double);\n\nstatic __inline unsigned __FLOAT_BITS(float __f)\n{\n\tunion {float __f; unsigned __i;} __u = {__f};\n\treturn __u.__i;\n}\nstatic __inline unsigned long long __DOUBLE_BITS(double __f)\n{\n\tunion {double __f; unsigned long long __i;} __u = {__f};\n\treturn __u.__i;\n}\n\n#define fpclassify(x) ( \\\n\tsizeof(x) == sizeof(float) ? __fpclassifyf(x) : \\\n\tsizeof(x) == sizeof(double) ? __fpclassify(x) : \\\n\t__fpclassifyl(x) )\n\n#define isinf(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) == 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) == 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) == FP_INFINITE)\n\n#define isnan(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) > 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) == FP_NAN)\n\n#define isnormal(x) ( \\\n\tsizeof(x) == sizeof(float) ? ((__FLOAT_BITS(x)+0x00800000) & 0x7fffffff) >= 0x01000000 : \\\n\tsizeof(x) == sizeof(double) ? ((__DOUBLE_BITS(x)+(1ULL<<52)) & -1ULL>>1) >= 1ULL<<53 : \\\n\t__fpclassifyl(x) == FP_NORMAL)\n\n#define isfinite(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) < 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) < 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) > FP_INFINITE)\n\nint __signbit(double);\nint __signbitf(float);\nint __signbitl(long double);\n\n#define signbit(x) ( \\\n\tsizeof(x) == sizeof(float) ? (int)(__FLOAT_BITS(x)>>31) : \\\n\tsizeof(x) == sizeof(double) ? (int)(__DOUBLE_BITS(x)>>63) : \\\n\t__signbitl(x) )\n\n#define isunordered(x,y) (isnan((x)) ? ((void)(y),1) : isnan((y)))\n\n#define __ISREL_DEF(rel, op, type) \\\nstatic __inline int __is##rel(type __x, type __y) \\\n{ return !isunordered(__x,__y) && __x op __y; }\n\n__ISREL_DEF(lessf, <, float)\n__ISREL_DEF(less, <, double)\n__ISREL_DEF(lessl, <, long double)\n__ISREL_DEF(lessequalf, <=, float)\n__ISREL_DEF(lessequal, <=, double)\n__ISREL_DEF(lessequall, <=, long double)\n__ISREL_DEF(lessgreaterf, !=, float)\n__ISREL_DEF(lessgreater, !=, double)\n__ISREL_DEF(lessgreaterl, !=, long double)\n__ISREL_DEF(greaterf, >, float)\n__ISREL_DEF(greater, >, double)\n__ISREL_DEF(greaterl, >, long double)\n__ISREL_DEF(greaterequalf, >=, float)\n__ISREL_DEF(greaterequal, >=, double)\n__ISREL_DEF(greaterequall, >=, long double)\n\n#define __tg_pred_2(x, y, p) ( \\\n\tsizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \\\n\tsizeof((x)+(y)) == sizeof(double) ? p(x, y) : \\\n\tp##l(x, y) )\n\n#define isless(x, y)            __tg_pred_2(x, y, __isless)\n#define islessequal(x, y)       __tg_pred_2(x, y, __islessequal)\n#define islessgreater(x, y)     __tg_pred_2(x, y, __islessgreater)\n#define isgreater(x, y)         __tg_pred_2(x, y, __isgreater)\n#define isgreaterequal(x, y)    __tg_pred_2(x, y, __isgreaterequal)\n\ndouble      acos(double);\nfloat       acosf(float);\nlong double acosl(long double);\n\ndouble      acosh(double);\nfloat       acoshf(float);\nlong double acoshl(long double);\n\ndouble      asin(double);\nfloat       asinf(float);\nlong double asinl(long double);\n\ndouble      asinh(double);\nfloat       asinhf(float);\nlong double asinhl(long double);\n\ndouble      atan(double);\nfloat       atanf(float);\nlong double atanl(long double);\n\ndouble      atan2(double, double);\nfloat       atan2f(float, float);\nlong double atan2l(long double, long double);\n\ndouble      atanh(double);\nfloat       atanhf(float);\nlong double atanhl(long double);\n\ndouble      cbrt(double);\nfloat       cbrtf(float);\nlong double cbrtl(long double);\n\ndouble      ceil(double);\nfloat       ceilf(float);\nlong double ceill(long double);\n\ndouble      copysign(double, double);\nfloat       copysignf(float, float);\nlong double copysignl(long double, long double);\n\ndouble      cos(double);\nfloat       cosf(float);\nlong double cosl(long double);\n\ndouble      cosh(double);\nfloat       coshf(float);\nlong double coshl(long double);\n\ndouble      erf(double);\nfloat       erff(float);\nlong double erfl(long double);\n\ndouble      erfc(double);\nfloat       erfcf(float);\nlong double erfcl(long double);\n\ndouble      exp(double);\nfloat       expf(float);\nlong double expl(long double);\n\ndouble      exp2(double);\nfloat       exp2f(float);\nlong double exp2l(long double);\n\ndouble      expm1(double);\nfloat       expm1f(float);\nlong double expm1l(long double);\n\ndouble      fabs(double);\nfloat       fabsf(float);\nlong double fabsl(long double);\n\ndouble      fdim(double, double);\nfloat       fdimf(float, float);\nlong double fdiml(long double, long double);\n\ndouble      floor(double);\nfloat       floorf(float);\nlong double floorl(long double);\n\ndouble      fma(double, double, double);\nfloat       fmaf(float, float, float);\nlong double fmal(long double, long double, long double);\n\ndouble      fmax(double, double);\nfloat       fmaxf(float, float);\nlong double fmaxl(long double, long double);\n\ndouble      fmin(double, double);\nfloat       fminf(float, float);\nlong double fminl(long double, long double);\n\ndouble      fmod(double, double);\nfloat       fmodf(float, float);\nlong double fmodl(long double, long double);\n\ndouble      frexp(double, int *);\nfloat       frexpf(float, int *);\nlong double frexpl(long double, int *);\n\ndouble      hypot(double, double);\nfloat       hypotf(float, float);\nlong double hypotl(long double, long double);\n\nint         ilogb(double);\nint         ilogbf(float);\nint         ilogbl(long double);\n\ndouble      ldexp(double, int);\nfloat       ldexpf(float, int);\nlong double ldexpl(long double, int);\n\ndouble      lgamma(double);\nfloat       lgammaf(float);\nlong double lgammal(long double);\n\nlong long   llrint(double);\nlong long   llrintf(float);\nlong long   llrintl(long double);\n\nlong long   llround(double);\nlong long   llroundf(float);\nlong long   llroundl(long double);\n\ndouble      log(double);\nfloat       logf(float);\nlong double logl(long double);\n\ndouble      log10(double);\nfloat       log10f(float);\nlong double log10l(long double);\n\ndouble      log1p(double);\nfloat       log1pf(float);\nlong double log1pl(long double);\n\ndouble      log2(double);\nfloat       log2f(float);\nlong double log2l(long double);\n\ndouble      logb(double);\nfloat       logbf(float);\nlong double logbl(long double);\n\nlong        lrint(double);\nlong        lrintf(float);\nlong        lrintl(long double);\n\nlong        lround(double);\nlong        lroundf(float);\nlong        lroundl(long double);\n\ndouble      modf(double, double *);\nfloat       modff(float, float *);\nlong double modfl(long double, long double *);\n\ndouble      nan(const char *);\nfloat       nanf(const char *);\nlong double nanl(const char *);\n\ndouble      nearbyint(double);\nfloat       nearbyintf(float);\nlong double nearbyintl(long double);\n\ndouble      nextafter(double, double);\nfloat       nextafterf(float, float);\nlong double nextafterl(long double, long double);\n\ndouble      nexttoward(double, long double);\nfloat       nexttowardf(float, long double);\nlong double nexttowardl(long double, long double);\n\ndouble      pow(double, double);\nfloat       powf(float, float);\nlong double powl(long double, long double);\n\ndouble      remainder(double, double);\nfloat       remainderf(float, float);\nlong double remainderl(long double, long double);\n\ndouble      remquo(double, double, int *);\nfloat       remquof(float, float, int *);\nlong double remquol(long double, long double, int *);\n\ndouble      rint(double);\nfloat       rintf(float);\nlong double rintl(long double);\n\ndouble      round(double);\nfloat       roundf(float);\nlong double roundl(long double);\n\ndouble      scalbln(double, long);\nfloat       scalblnf(float, long);\nlong double scalblnl(long double, long);\n\ndouble      scalbn(double, int);\nfloat       scalbnf(float, int);\nlong double scalbnl(long double, int);\n\ndouble      sin(double);\nfloat       sinf(float);\nlong double sinl(long double);\n\ndouble      sinh(double);\nfloat       sinhf(float);\nlong double sinhl(long double);\n\ndouble      sqrt(double);\nfloat       sqrtf(float);\nlong double sqrtl(long double);\n\ndouble      tan(double);\nfloat       tanf(float);\nlong double tanl(long double);\n\ndouble      tanh(double);\nfloat       tanhf(float);\nlong double tanhl(long double);\n\ndouble      tgamma(double);\nfloat       tgammaf(float);\nlong double tgammal(long double);\n\ndouble      trunc(double);\nfloat       truncf(float);\nlong double truncl(long double);\n\n\n#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE)\n#undef  MAXFLOAT\n#define MAXFLOAT        3.40282347e+38F\n#endif\n\n#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\n#define M_E             2.7182818284590452354   /* e */\n#define M_LOG2E         1.4426950408889634074   /* log_2 e */\n#define M_LOG10E        0.43429448190325182765  /* log_10 e */\n#define M_LN2           0.69314718055994530942  /* log_e 2 */\n#define M_LN10          2.30258509299404568402  /* log_e 10 */\n#define M_PI            3.14159265358979323846  /* pi */\n#define M_PI_2          1.57079632679489661923  /* pi/2 */\n#define M_PI_4          0.78539816339744830962  /* pi/4 */\n#define M_1_PI          0.31830988618379067154  /* 1/pi */\n#define M_2_PI          0.63661977236758134308  /* 2/pi */\n#define M_2_SQRTPI      1.12837916709551257390  /* 2/sqrt(pi) */\n#define M_SQRT2         1.41421356237309504880  /* sqrt(2) */\n#define M_SQRT1_2       0.70710678118654752440  /* 1/sqrt(2) */\n\nextern int signgam;\n\ndouble      j0(double);\ndouble      j1(double);\ndouble      jn(int, double);\n\ndouble      y0(double);\ndouble      y1(double);\ndouble      yn(int, double);\n#endif\n\n#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\n#define HUGE            3.40282347e+38F\n\ndouble      scalb(double, double);\nfloat       scalbf(float, float);\n\ndouble      significand(double);\nfloat       significandf(float);\n\ndouble      lgamma_r(double, int*);\nfloat       lgammaf_r(float, int*);\n\nfloat       j0f(float);\nfloat       j1f(float);\nfloat       jnf(int, float);\n\nfloat       y0f(float);\nfloat       y1f(float);\nfloat       ynf(int, float);\n#endif\n\n#ifdef _GNU_SOURCE\nlong double lgammal_r(long double, int*);\n\nvoid        sincos(double, double*, double*);\nvoid        sincosf(float, float*, float*);\nvoid        sincosl(long double, long double*, long double*);\n\ndouble      exp10(double);\nfloat       exp10f(float);\nlong double exp10l(long double);\n\ndouble      pow10(double);\nfloat       pow10f(float);\nlong double pow10l(long double);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","#include \"eval.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"builtins.h\"\n#include \"util.h\"\n\n#define AWLENV_DEL_RECURSING(e) { \\\n    if (recursing) { \\\n        awlenv_del(e); \\\n    } \\\n}\n\nstatic bool eval_aborted = false;\n\nvoid awlval_eval_abort(void) {\n    eval_aborted = true;\n}\n\nawlval* awlval_eval(awlenv* e, awlval* v) {\n    bool recursing = false;\n\n    while (true) {\n        // Handle abort\n        if (eval_aborted) {\n            AWLENV_DEL_RECURSING(e);\n            awlval_del(v);\n\n            eval_aborted = false;\n            return awlval_err(\"eval aborted\");\n        }\n\n        switch (v->type) {\n            case AWLVAL_SYM:\n            {\n                awlval* x = awlenv_get(e, v);\n                awlval_del(v);\n                AWLENV_DEL_RECURSING(e);\n                return x;\n                break;\n            }\n\n            case AWLVAL_SEXPR:\n            {\n                awlval* x = awlval_eval_sexpr(e, v);\n\n                /* recursively evaluate results */\n                if (x->type == AWLVAL_FN && x->called) {\n                    AWLENV_DEL_RECURSING(e);\n                    recursing = true;\n\n                    e = awlenv_copy(x->env);\n                    v = awlval_copy(x->body);\n\n                    awlval_del(x);\n                } else {\n                    /* evaluate result in next loop */\n                    v = x;\n                }\n                break;\n            }\n\n            case AWLVAL_QEXPR:\n            {\n                awlval* x = awlval_eval_inside_qexpr(e, v);\n                AWLENV_DEL_RECURSING(e);\n                return x;\n                break;\n            }\n\n            case AWLVAL_EEXPR:\n            case AWLVAL_CEXPR:\n            {\n                AWLENV_DEL_RECURSING(e);\n                return awlval_err(\"cannot directly evaluate %s; must be contained inside %s\",\n                        awlval_type_name(v->type), awlval_type_name(AWLVAL_QEXPR));\n            }\n\n            default:\n                AWLENV_DEL_RECURSING(e);\n                return v;\n                break;\n        }\n    }\n}\n\nawlval* awlval_eval_arg(awlenv* e, awlval* v, int arg) {\n    v->cell[arg] = awlval_eval(e, v->cell[arg]);\n    if (v->cell[arg]->type == AWLVAL_ERR) {\n        return awlval_take(v, arg);\n    }\n    return v;\n}\n\nawlval* awlval_eval_args(awlenv* e, awlval* v) {\n    for (int i = 0; i < v->count; i++) {\n        v->cell[i] = awlval_eval(e, v->cell[i]);\n    }\n\n    for (int i = 0; i < v->count; i++) {\n        if (v->cell[i]->type == AWLVAL_ERR) {\n            return awlval_take(v, i);\n        }\n    }\n    return v;\n}\n\nawlval* awlval_eval_sexpr(awlenv* e, awlval* v) {\n    if (v->count == 0) {\n        awlval_del(v);\n        return awlval_err(\"cannot evaluate empty %s\", awlval_type_name(AWLVAL_SEXPR));\n    }\n\n    EVAL_SINGLE_ARG(e, v, 0);\n    awlval* f = awlval_pop(v, 0);\n\n    if (!ISCALLABLE(f->type)) {\n        awlval* err = awlval_err(\"cannot evaluate %s; incorrect type for arg 0; got %s, expected callable\",\n                awlval_type_name(AWLVAL_SEXPR), awlval_type_name(f->type));\n        awlval_del(v);\n        awlval_del(f);\n        return err;\n    }\n\n    awlval* result = awlval_call(e, f, v);\n    awlval_del(f);\n    return result;\n}\n\nawlval* awlval_call(awlenv* e, awlval* f, awlval* a) {\n    /* calls a function if builtin, or evals a macro, else fills in the\n     * corresponding parameters, and lets awlval_eval perform tail\n     * call optimization\n     */\n    if (f->type == AWLVAL_BUILTIN) {\n        return f->builtin(e, a);\n    }\n\n    int given = a->count;\n    int total = f->formals->count;\n\n    /* special case for macros */\n    if (f->type == AWLVAL_MACRO) {\n        for (int i = 0; i < a->count; i++) {\n            /* wrap SExprs and Symbols in QExprs to avoid evaluation */\n            if (a->cell[i]->type == AWLVAL_SEXPR) {\n                awlval* q = awlval_qexpr();\n                q = awlval_add(q, a->cell[i]);\n                a->cell[i] = q;\n            } else if (a->cell[i]->type == AWLVAL_SYM) {\n                awlval* q = awlval_qexpr();\n                q = awlval_add(q, a->cell[i]);\n                a->cell[i] = q;\n            }\n        }\n    }\n\n    while (a->count) {\n        if (f->formals->count == 0) {\n            awlval_del(a);\n            return awlval_err(\"%s passed too many arguments; got %i, expected %i\",\n                    awlval_type_name(f->type), given, total);\n        }\n        awlval* sym = awlval_pop(f->formals, 0);\n\n        /* special case for variadic functions */\n        if (streq(sym->sym, \"&\")) {\n            if (f->formals->count != 1) {\n                awlval_del(a);\n                return awlval_err(\"function format invalid; symbol '&' not followed by single symbol\");\n            }\n\n            awlval* nsym = awlval_pop(f->formals, 0);\n            awlval* varargs = builtin_list(e, a);\n\n            if (varargs->type == AWLVAL_ERR) {\n                awlval_del(sym);\n                awlval_del(nsym);\n                return varargs;\n            }\n\n            awlenv_put(f->env, nsym, varargs, false);\n            awlval_del(sym);\n            awlval_del(nsym);\n            break;\n        }\n\n        awlval* val = awlval_eval(e, awlval_pop(a, 0));\n        if (val->type == AWLVAL_ERR) {\n            awlval_del(sym);\n            awlval_del(a);\n            return val;\n        }\n\n        awlenv_put(f->env, sym, val, false);\n        awlval_del(sym);\n        awlval_del(val);\n    }\n\n    /* Special case for pure variadic function with no arguments */\n    if (f->formals->count > 0 &&\n            streq(f->formals->cell[0]->sym, \"&\")) {\n        if (f->formals->count != 2) {\n            return awlval_err(\"function format invalid; symbol '&' not followed by single symbol\");\n        }\n        awlval_del(awlval_pop(f->formals, 0));\n        awlval* sym = awlval_pop(f->formals, 0);\n        awlval* val = awlval_qexpr();\n\n        awlenv_put(f->env, sym, val, false);\n        awlval_del(sym);\n        awlval_del(val);\n    }\n\n    if (f->formals->count == 0) {\n        f->called = true;\n    }\n\n    awlval_del(a);\n\n    /* Handle macros -- they are called directly because their output must\n     * be evaluated in the enclosing environment */\n    if (f->type == AWLVAL_MACRO && f->called) {\n        return awlval_eval_macro(f);\n    } else {\n        return awlval_copy(f);\n    }\n}\n\nawlval* awlval_eval_macro(awlval* m) {\n    awlenv* e = awlenv_copy(m->env);\n    awlval* b = awlval_copy(m->body);\n\n    awlval* v = awlval_eval(e, b);\n\n    awlenv_del(e);\n\n    if (v->type == AWLVAL_QEXPR) {\n        v->type = AWLVAL_SEXPR;\n    }\n    return v;\n}\n\nawlval* awlval_eval_inside_qexpr(awlenv* e, awlval* v) {\n    switch (v->type) {\n        case AWLVAL_SEXPR:\n        case AWLVAL_QEXPR:\n        {\n            for (int i = 0; i < v->count; i++) {\n                // Special case for C-Expressions\n                if (v->cell[i]->type == AWLVAL_CEXPR) {\n                    awlval* cexpr = awlval_eval_cexpr(e, awlval_pop(v, i));\n                    if (cexpr->type == AWLVAL_ERR) {\n                        awlval_del(v);\n                        return cexpr;\n                    }\n\n                    // Populate current container with result of CExpr\n                    if (cexpr->type == AWLVAL_QEXPR) {\n                        v = awlval_shift(v, cexpr, i);\n                    } else {\n                        v = awlval_insert(v, cexpr, i);\n                    }\n                } else {\n                    v->cell[i] = awlval_eval_inside_qexpr(e, v->cell[i]);\n                    if (v->cell[i]->type == AWLVAL_ERR) {\n                        return awlval_take(v, i);\n                    }\n                }\n            }\n            return v;\n            break;\n        }\n\n        case AWLVAL_EEXPR:\n        {\n            return awlval_eval(e, awlval_take(v, 0));\n            break;\n\n        }\n\n        default:\n            return v;\n            break;\n    }\n}\n\nawlval* awlval_eval_cexpr(awlenv* e, awlval* v) {\n    awlval* res = awlval_eval(e, awlval_take(v, 0));\n    if (res->type == AWLVAL_ERR) {\n        return res;\n    }\n    return res;\n}\n","#include \"mpc.h\"\n\n/*\n** State Type\n*/\n\nstatic mpc_state_t mpc_state_invalid(void) {\n  mpc_state_t s;\n  s.pos = -1;\n  s.row = -1;\n  s.col = -1;\n  return s;\n}\n\nstatic mpc_state_t mpc_state_new(void) {\n  mpc_state_t s;\n  s.pos = 0;\n  s.row = 0;\n  s.col = 0;\n  return s;\n}\n\nstatic mpc_state_t *mpc_state_copy(mpc_state_t s) {\n  mpc_state_t *r = malloc(sizeof(mpc_state_t));\n  memcpy(r, &s, sizeof(mpc_state_t));\n  return r;\n}\n\n/*\n** Error Type\n*/\n\nstatic mpc_err_t *mpc_err_new(const char *filename, mpc_state_t s, const char *expected, char recieved) {\n  mpc_err_t *x = malloc(sizeof(mpc_err_t));\n  x->filename = malloc(strlen(filename) + 1);\n  strcpy(x->filename, filename);\n  x->state = s;\n  x->expected_num = 1;\n  x->expected = malloc(sizeof(char*));\n  x->expected[0] = malloc(strlen(expected) + 1);\n  strcpy(x->expected[0], expected);\n  x->failure = NULL;\n  x->recieved = recieved;\n  return x;\n}\n\nstatic mpc_err_t *mpc_err_fail(const char *filename, mpc_state_t s, const char *failure) {\n  mpc_err_t *x = malloc(sizeof(mpc_err_t));\n  x->filename = malloc(strlen(filename) + 1);\n  strcpy(x->filename, filename);\n  x->state = s;\n  x->expected_num = 0;\n  x->expected = NULL;\n  x->failure = malloc(strlen(failure) + 1);\n  strcpy(x->failure, failure);\n  x->recieved = ' ';\n  return x;\n}\n\nvoid mpc_err_delete(mpc_err_t *x) {\n\n  int i;\n  for (i = 0; i < x->expected_num; i++) {\n    free(x->expected[i]);\n  }\n  \n  free(x->expected);\n  free(x->filename);\n  free(x->failure);\n  free(x);\n}\n\nstatic int mpc_err_contains_expected(mpc_err_t *x, char *expected) {\n  \n  int i;\n  for (i = 0; i < x->expected_num; i++) {\n    if (strcmp(x->expected[i], expected) == 0) { return 1; }\n  }\n  \n  return 0;\n}\n\nstatic void mpc_err_add_expected(mpc_err_t *x, char *expected) {\n  \n  x->expected_num++;\n  x->expected = realloc(x->expected, sizeof(char*) * x->expected_num);\n  x->expected[x->expected_num-1] = malloc(strlen(expected) + 1);\n  strcpy(x->expected[x->expected_num-1], expected);\n  \n}\n\nstatic void mpc_err_clear_expected(mpc_err_t *x, char *expected) {\n  \n  int i;\n  for (i = 0; i < x->expected_num; i++) {\n    free(x->expected[i]);\n  }\n  x->expected_num = 1;\n  x->expected = realloc(x->expected, sizeof(char*) * x->expected_num);\n  x->expected[0] = malloc(strlen(expected) + 1);\n  strcpy(x->expected[0], expected);\n  \n}\n\nvoid mpc_err_print(mpc_err_t *x) {\n  mpc_err_print_to(x, stdout);\n}\n\nvoid mpc_err_print_to(mpc_err_t *x, FILE *f) {\n  char *str = mpc_err_string(x);\n  fprintf(f, \"%s\", str);\n  free(str);\n}\n\nvoid mpc_err_string_cat(char *buffer, int *pos, int *max, char *fmt, ...) {\n  /* TODO: Error Checking on Length */\n  int left = ((*max) - (*pos));\n  va_list va;\n  va_start(va, fmt);\n  if (left < 0) { left = 0;}\n  (*pos) += vsprintf(buffer + (*pos), fmt, va);\n  va_end(va);\n}\n\nstatic char char_unescape_buffer[3];\n\nstatic char *mpc_err_char_unescape(char c) {\n  \n  char_unescape_buffer[0] = '\\'';\n  char_unescape_buffer[1] = ' ';\n  char_unescape_buffer[2] = '\\'';\n  \n  switch (c) {\n    \n    case '\\a': return \"bell\";\n    case '\\b': return \"backspace\";\n    case '\\f': return \"formfeed\";\n    case '\\r': return \"carriage return\";\n    case '\\v': return \"vertical tab\";\n    case '\\0': return \"end of input\";\n    case '\\n': return \"newline\";\n    case '\\t': return \"tab\";\n    case ' ' : return \"space\";\n    default:\n      char_unescape_buffer[1] = c;\n      return char_unescape_buffer;\n  }\n  \n}\n\nchar *mpc_err_string(mpc_err_t *x) {\n  \n  char *buffer = calloc(1, 1024);\n  int max = 1023;\n  int pos = 0; \n  int i;\n  \n  if (x->failure) {\n    mpc_err_string_cat(buffer, &pos, &max,\n    \"error: %s\\n\", \n      x->filename, x->state.row+1, \n      x->state.col+1, x->failure);\n    return buffer;\n  }\n  \n  mpc_err_string_cat(buffer, &pos, &max, \n    \"%s:%i:%i: error: expected \", x->filename, x->state.row+1, x->state.col+1);\n  \n  if (x->expected_num == 0) { mpc_err_string_cat(buffer, &pos, &max, \"ERROR: NOTHING EXPECTED\"); }\n  if (x->expected_num == 1) { mpc_err_string_cat(buffer, &pos, &max, \"%s\", x->expected[0]); }\n  if (x->expected_num >= 2) {\n  \n    for (i = 0; i < x->expected_num-2; i++) {\n      mpc_err_string_cat(buffer, &pos, &max, \"%s, \", x->expected[i]);\n    } \n    \n    mpc_err_string_cat(buffer, &pos, &max, \"%s or %s\", \n      x->expected[x->expected_num-2], \n      x->expected[x->expected_num-1]);\n  }\n  \n  mpc_err_string_cat(buffer, &pos, &max, \" at \");\n  mpc_err_string_cat(buffer, &pos, &max, mpc_err_char_unescape(x->recieved));\n  mpc_err_string_cat(buffer, &pos, &max, \"\\n\");\n  \n  return realloc(buffer, strlen(buffer) + 1);\n}\n\nstatic mpc_err_t *mpc_err_or(mpc_err_t** x, int n) {\n  \n  int i, j;\n  mpc_err_t *e = malloc(sizeof(mpc_err_t));\n  e->state = mpc_state_invalid();\n  e->expected_num = 0;\n  e->expected = NULL;\n  e->failure = NULL;\n  e->filename = malloc(strlen(x[0]->filename)+1);\n  strcpy(e->filename, x[0]->filename);\n  \n  for (i = 0; i < n; i++) {\n    if (x[i]->state.pos > e->state.pos) { e->state = x[i]->state; }\n  }\n  \n  for (i = 0; i < n; i++) {\n    \n    if (x[i]->state.pos < e->state.pos) { continue; }\n    \n    if (x[i]->failure) {\n      e->failure = malloc(strlen(x[i]->failure)+1);\n      strcpy(e->failure, x[i]->failure);\n      break;\n    }\n    \n    e->recieved = x[i]->recieved;\n    \n    for (j = 0; j < x[i]->expected_num; j++) {\n      if (!mpc_err_contains_expected(e, x[i]->expected[j])) { mpc_err_add_expected(e, x[i]->expected[j]); }\n    }\n  }\n  \n  for (i = 0; i < n; i++) {\n    mpc_err_delete(x[i]);\n  }\n  \n  return e;\n}\n\nstatic mpc_err_t *mpc_err_repeat(mpc_err_t *x, const char *prefix) {\n\n  int i;\n  char *expect = malloc(strlen(prefix) + 1);\n  strcpy(expect, prefix);\n  \n  if (x->expected_num == 1) {\n    expect = realloc(expect, strlen(expect) + strlen(x->expected[0]) + 1);\n    strcat(expect, x->expected[0]);\n  }\n  \n  if (x->expected_num > 1) {\n  \n    for (i = 0; i < x->expected_num-2; i++) {\n      expect = realloc(expect, strlen(expect) + strlen(x->expected[i]) + strlen(\", \") + 1);\n      strcat(expect, x->expected[i]);\n      strcat(expect, \", \");\n    }\n    \n    expect = realloc(expect, strlen(expect) + strlen(x->expected[x->expected_num-2]) + strlen(\" or \") + 1);\n    strcat(expect, x->expected[x->expected_num-2]);\n    strcat(expect, \" or \");\n    expect = realloc(expect, strlen(expect) + strlen(x->expected[x->expected_num-1]) + 1);\n    strcat(expect, x->expected[x->expected_num-1]);\n\n  }\n  \n  mpc_err_clear_expected(x, expect);\n  free(expect);\n  \n  return x;\n\n}\n\nstatic mpc_err_t *mpc_err_many1(mpc_err_t *x) {\n  return mpc_err_repeat(x, \"one or more of \");\n}\n\nstatic mpc_err_t *mpc_err_count(mpc_err_t *x, int n) {\n  mpc_err_t *y;\n  int digits = n/10 + 1;\n  char *prefix = malloc(digits + strlen(\" of \") + 1);\n  sprintf(prefix, \"%i of \", n);\n  y = mpc_err_repeat(x, prefix);\n  free(prefix);\n  return y;\n}\n\n/*\n** Input Type\n*/\n\n/*\n** In mpc the input type has three modes of \n** operation: String, File and Pipe.\n**\n** String is easy. The whole contents are \n** loaded into a buffer and scanned through.\n** The cursor can jump around at will making \n** backtracking easy.\n**\n** The second is a File which is also somewhat\n** easy. The contents are never loaded into \n** memory but backtracking can still be achieved\n** by seeking in the file at different positions.\n**\n** The final mode is Pipe. This is the difficult\n** one. As we assume pipes cannot be seeked - and \n** only support a single character lookahead at \n** any point, when the input is marked for a \n** potential backtracking we start buffering any \n** input.\n**\n** This means that if we are requested to seek\n** back we can simply start reading from the\n** buffer instead of the input.\n**\n** Of course using `mpc_predictive` will disable\n** backtracking and make LL(1) grammars easy\n** to parse for all input methods.\n**\n*/\n\nenum {\n  MPC_INPUT_STRING = 0,\n  MPC_INPUT_FILE   = 1,\n  MPC_INPUT_PIPE   = 2\n};\n\ntypedef struct {\n\n  int type;\n  char *filename;  \n  mpc_state_t state;\n  \n  char *string;\n  char *buffer;\n  FILE *file;\n  \n  int backtrack;\n  int marks_num;\n  mpc_state_t* marks;\n  int* lasts;\n  \n  char last;\n  \n} mpc_input_t;\n\nstatic mpc_input_t *mpc_input_new_string(const char *filename, const char *string) {\n\n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\n  \n  i->filename = malloc(strlen(filename) + 1);\n  strcpy(i->filename, filename);\n  i->type = MPC_INPUT_STRING;\n  \n  i->state = mpc_state_new();\n  \n  i->string = malloc(strlen(string) + 1);\n  strcpy(i->string, string);\n  i->buffer = NULL;\n  i->file = NULL;\n  \n  i->backtrack = 1;\n  i->marks_num = 0;\n  i->marks = NULL;\n  i->lasts = NULL;\n\n  i->last = -1;\n  \n  return i;\n}\n\nstatic mpc_input_t *mpc_input_new_pipe(const char *filename, FILE *pipe) {\n\n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\n  \n  i->filename = malloc(strlen(filename) + 1);\n  strcpy(i->filename, filename);\n  \n  i->type = MPC_INPUT_PIPE;\n  i->state = mpc_state_new();\n  \n  i->string = NULL;\n  i->buffer = NULL;\n  i->file = pipe;\n  \n  i->backtrack = 1;\n  i->marks_num = 0;\n  i->marks = NULL;\n  i->lasts = NULL;\n  \n  i->last = -1;\n  \n  return i;\n  \n}\n\nstatic mpc_input_t *mpc_input_new_file(const char *filename, FILE *file) {\n  \n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\n  \n  i->filename = malloc(strlen(filename) + 1);\n  strcpy(i->filename, filename);\n  i->type = MPC_INPUT_FILE;\n  i->state = mpc_state_new();\n  \n  i->string = NULL;\n  i->buffer = NULL;\n  i->file = file;\n  \n  i->backtrack = 1;\n  i->marks_num = 0;\n  i->marks = NULL;\n  i->lasts = NULL;\n  \n  i->last = -1;\n  \n  return i;\n}\n\nstatic void mpc_input_delete(mpc_input_t *i) {\n  \n  free(i->filename);\n  \n  if (i->type == MPC_INPUT_STRING) { free(i->string); }\n  if (i->type == MPC_INPUT_PIPE) { free(i->buffer); }\n  \n  free(i->marks);\n  free(i->lasts);\n  free(i);\n}\n\nstatic void mpc_input_backtrack_disable(mpc_input_t *i) { i->backtrack--; }\nstatic void mpc_input_backtrack_enable(mpc_input_t *i) { i->backtrack++; }\n\nstatic void mpc_input_mark(mpc_input_t *i) {\n  \n  if (i->backtrack < 1) { return; }\n  \n  i->marks_num++;\n  i->marks = realloc(i->marks, sizeof(mpc_state_t) * i->marks_num);\n  i->lasts = realloc(i->lasts, sizeof(int) * i->marks_num);\n  i->marks[i->marks_num-1] = i->state;\n  i->lasts[i->marks_num-1] = i->last;\n  \n  if (i->type == MPC_INPUT_PIPE && i->marks_num == 1) {\n    i->buffer = calloc(1, 1);\n  }\n  \n}\n\nstatic void mpc_input_unmark(mpc_input_t *i) {\n  \n  if (i->backtrack < 1) { return; }\n  \n  i->marks_num--;\n  i->marks = realloc(i->marks, sizeof(mpc_state_t) * i->marks_num);\n  i->lasts = realloc(i->lasts, sizeof(int) * i->marks_num);\n  \n  if (i->type == MPC_INPUT_PIPE && i->marks_num == 0) {\n    free(i->buffer);\n    i->buffer = NULL;\n  }\n  \n}\n\nstatic void mpc_input_rewind(mpc_input_t *i) {\n  \n  if (i->backtrack < 1) { return; }\n  \n  i->state = i->marks[i->marks_num-1];\n  i->last = i->lasts[i->marks_num-1];\n  \n  if (i->type == MPC_INPUT_FILE) {\n    fseek(i->file, i->state.pos, SEEK_SET);\n  }\n  \n  mpc_input_unmark(i);\n}\n\nstatic int mpc_input_buffer_in_range(mpc_input_t *i) {\n  return i->state.pos < (strlen(i->buffer) + i->marks[0].pos);\n}\n\nstatic char mpc_input_buffer_get(mpc_input_t *i) {\n  return i->buffer[i->state.pos - i->marks[0].pos];\n}\n\nstatic int mpc_input_terminated(mpc_input_t *i) {\n  if (i->type == MPC_INPUT_STRING && i->state.pos == strlen(i->string)) { return 1; }\n  if (i->type == MPC_INPUT_FILE && feof(i->file)) { return 1; }\n  if (i->type == MPC_INPUT_PIPE && feof(i->file)) { return 1; }\n  return 0;\n}\n\nstatic char mpc_input_getc(mpc_input_t *i) {\n  \n  char c;\n  switch (i->type) {\n    \n    case MPC_INPUT_STRING: c = i->string[i->state.pos]; break;\n    case MPC_INPUT_FILE: c = fgetc(i->file); break;\n    case MPC_INPUT_PIPE:\n    \n      if (!i->buffer) { c = getc(i->file); break; }\n      \n      if (i->buffer && mpc_input_buffer_in_range(i)) {\n        c = mpc_input_buffer_get(i);\n      } else {\n        c = getc(i->file);\n      }\n    \n    break;\n    \n  }\n  \n  return c;\n}\n\nstatic char mpc_input_peekc(mpc_input_t *i) {\n  \n  char c;\n  \n  switch (i->type) {\n    case MPC_INPUT_STRING: return i->string[i->state.pos];\n    case MPC_INPUT_FILE: \n      \n      if (feof(i->file)) { return '\\0'; }\n      \n      c = fgetc(i->file);\n      fseek(i->file, -1, SEEK_CUR);\n      break;\n    \n    case MPC_INPUT_PIPE:\n      \n      if (feof(i->file)) { return '\\0'; }\n      \n      if (!i->buffer) { c = getc(i->file); ungetc(c, i->file); break; }\n      \n      if (i->buffer && mpc_input_buffer_in_range(i)) {\n        return mpc_input_buffer_get(i);\n      } else {\n        c = getc(i->file); ungetc(c, i->file);\n        break;\n      }\n      \n  }\n  \n  return c;\n  \n}\n\nstatic int mpc_input_failure(mpc_input_t *i, char c) {\n\n  switch (i->type) {\n    case MPC_INPUT_STRING: break;\n    case MPC_INPUT_FILE: fseek(i->file, -1, SEEK_CUR); break;\n    case MPC_INPUT_PIPE:\n      \n      if (!i->buffer) { ungetc(c, i->file); break; }\n      \n      if (i->buffer && mpc_input_buffer_in_range(i)) {\n        break;\n      } else {\n        ungetc(c, i->file); \n      }\n      \n  }\n  \n  return 0;\n}\n\nstatic int mpc_input_success(mpc_input_t *i, char c, char **o) {\n  \n  if (i->type == MPC_INPUT_PIPE &&\n      i->buffer &&\n      !mpc_input_buffer_in_range(i)) {\n    \n    i->buffer = realloc(i->buffer, strlen(i->buffer) + 2);\n    i->buffer[strlen(i->buffer) + 1] = '\\0';\n    i->buffer[strlen(i->buffer) + 0] = c;\n  }\n  \n  i->last = c;\n  i->state.pos++;\n  i->state.col++;\n  \n  if (c == '\\n') {\n    i->state.col = 0;\n    i->state.row++;\n  }\n  \n  if (o) {\n    (*o) = malloc(2);\n    (*o)[0] = c;\n    (*o)[1] = '\\0';\n  }\n  \n  return 1;\n}\n\nstatic int mpc_input_eoi(mpc_input_t *i) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 1; }\n  else { return mpc_input_failure(i, x); }\n}\n\nstatic int mpc_input_soi(mpc_input_t *i) {\n  return (i->state.pos == 0);\n}\n\nstatic int mpc_input_any(mpc_input_t *i, char **o) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 0; }\n  return mpc_input_success(i, x, o);\n}\n\nstatic int mpc_input_char(mpc_input_t *i, char c, char **o) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 0; }\n  return x == c ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);\n}\n\nstatic int mpc_input_range(mpc_input_t *i, char c, char d, char **o) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 0; }\n  return x >= c && x <= d ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);  \n}\n\nstatic int mpc_input_oneof(mpc_input_t *i, const char *c, char **o) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 0; }\n  return strchr(c, x) != 0 ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);  \n}\n\nstatic int mpc_input_noneof(mpc_input_t *i, const char *c, char **o) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 0; }\n  return strchr(c, x) == 0 ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);  \n}\n\nstatic int mpc_input_satisfy(mpc_input_t *i, int(*cond)(char), char **o) {\n  char x = mpc_input_getc(i);\n  if (mpc_input_terminated(i)) { return 0; }\n  return cond(x) ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);  \n}\n\nstatic int mpc_input_string(mpc_input_t *i, const char *c, char **o) {\n  \n  char *co = NULL;\n  const char *x = c;\n\n  mpc_input_mark(i);\n  while (*x) {\n    if (mpc_input_char(i, *x, &co)) {\n      free(co);\n    } else {\n      mpc_input_rewind(i);\n      return 0;\n    }\n    x++;\n  }\n  mpc_input_unmark(i);\n  \n  *o = malloc(strlen(c) + 1);\n  strcpy(*o, c);\n  return 1;\n}\n\nstatic int mpc_input_boundary(mpc_input_t* i) {\n  \n  char* word = \"abcdefghijklmnopqrstuvwxyz\"\n               \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t       \"0123456789_\";\n\t       \n  char peek = mpc_input_peekc(i);\n  if (strchr(word, i->last) && peek == '\\0') { return 1; }\n  if (strchr(word, peek) && !strchr(word, i->last)) { return 1; }\n  if (!strchr(word, peek) && strchr(word, i->last)) { return 1; }\n  \n  return 0;\n}\n\n/*\n** Parser Type\n*/\n\nenum {\n  MPC_TYPE_UNDEFINED = 0,\n  MPC_TYPE_PASS      = 1,\n  MPC_TYPE_FAIL      = 2,\n  MPC_TYPE_LIFT      = 3,\n  MPC_TYPE_LIFT_VAL  = 4,\n  MPC_TYPE_EXPECT    = 5,\n  MPC_TYPE_BOUNDARY  = 6,\n  MPC_TYPE_STATE     = 7,\n  \n  MPC_TYPE_SOI       = 8,\n  MPC_TYPE_EOI       = 9,\n  MPC_TYPE_ANY       = 10,\n  MPC_TYPE_SINGLE    = 11,\n  MPC_TYPE_ONEOF     = 12,\n  MPC_TYPE_NONEOF    = 13,\n  MPC_TYPE_RANGE     = 14,\n  MPC_TYPE_SATISFY   = 15,\n  MPC_TYPE_STRING    = 16,\n  \n  MPC_TYPE_APPLY     = 17,\n  MPC_TYPE_APPLY_TO  = 18,\n  MPC_TYPE_PREDICT   = 19,\n  MPC_TYPE_NOT       = 20,\n  MPC_TYPE_MAYBE     = 21,\n  MPC_TYPE_MANY      = 22,\n  MPC_TYPE_MANY1     = 23,\n  MPC_TYPE_COUNT     = 24,\n  \n  MPC_TYPE_OR        = 25,\n  MPC_TYPE_AND       = 26\n};\n\ntypedef struct { char *m; } mpc_pdata_fail_t;\ntypedef struct { mpc_ctor_t lf; void *x; } mpc_pdata_lift_t;\ntypedef struct { mpc_parser_t *x; char *m; } mpc_pdata_expect_t;\ntypedef struct { char x; } mpc_pdata_single_t;\ntypedef struct { char x; char y; } mpc_pdata_range_t;\ntypedef struct { int(*f)(char); } mpc_pdata_satisfy_t;\ntypedef struct { char *x; } mpc_pdata_string_t;\ntypedef struct { mpc_parser_t *x; mpc_apply_t f; } mpc_pdata_apply_t;\ntypedef struct { mpc_parser_t *x; mpc_apply_to_t f; void *d; } mpc_pdata_apply_to_t;\ntypedef struct { mpc_parser_t *x; } mpc_pdata_predict_t;\ntypedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_ctor_t lf; } mpc_pdata_not_t;\ntypedef struct { int n; mpc_fold_t f; mpc_parser_t *x; mpc_dtor_t dx; } mpc_pdata_repeat_t;\ntypedef struct { int n; mpc_parser_t **xs; } mpc_pdata_or_t;\ntypedef struct { int n; mpc_fold_t f; mpc_parser_t **xs; mpc_dtor_t *dxs;  } mpc_pdata_and_t;\n\ntypedef union {\n  mpc_pdata_fail_t fail;\n  mpc_pdata_lift_t lift;\n  mpc_pdata_expect_t expect;\n  mpc_pdata_single_t single;\n  mpc_pdata_range_t range;\n  mpc_pdata_satisfy_t satisfy;\n  mpc_pdata_string_t string;\n  mpc_pdata_apply_t apply;\n  mpc_pdata_apply_to_t apply_to;\n  mpc_pdata_predict_t predict;\n  mpc_pdata_not_t not;\n  mpc_pdata_repeat_t repeat;\n  mpc_pdata_and_t and;\n  mpc_pdata_or_t or;\n} mpc_pdata_t;\n\nstruct mpc_parser_t {\n  char retained;\n  char *name;\n  char type;\n  mpc_pdata_t data;\n};\n\n/*\n** Stack Type\n*/\n\ntypedef struct {\n\n  int parsers_num;\n  int parsers_slots;\n  mpc_parser_t **parsers;\n  int *states;\n\n  int results_num;\n  int results_slots;\n  mpc_result_t *results;\n  int *returns;\n  \n  mpc_err_t *err;\n  \n} mpc_stack_t;\n\nstatic mpc_stack_t *mpc_stack_new(const char *filename) {\n  mpc_stack_t *s = malloc(sizeof(mpc_stack_t));\n  \n  s->parsers_num = 0;\n  s->parsers_slots = 0;\n  s->parsers = NULL;\n  s->states = NULL;\n  \n  s->results_num = 0;\n  s->results_slots = 0;\n  s->results = NULL;\n  s->returns = NULL;\n  \n  s->err = mpc_err_fail(filename, mpc_state_invalid(), \"Unknown Error\");\n  \n  return s;\n}\n\nstatic void mpc_stack_err(mpc_stack_t *s, mpc_err_t* e) {\n  mpc_err_t *errs[2];\n  errs[0] = s->err;\n  errs[1] = e;\n  s->err = mpc_err_or(errs, 2);\n}\n\nstatic int mpc_stack_terminate(mpc_stack_t *s, mpc_result_t *r) {\n  int success = s->returns[0];\n  \n  if (success) {\n    r->output = s->results[0].output;\n    mpc_err_delete(s->err);\n  } else {\n    mpc_stack_err(s, s->results[0].error);\n    r->error = s->err;\n  }\n  \n  free(s->parsers);\n  free(s->states);\n  free(s->results);\n  free(s->returns);\n  free(s);\n  \n  return success;\n}\n\n/* Stack Parser Stuff */\n\nstatic void mpc_stack_set_state(mpc_stack_t *s, int x) {\n  s->states[s->parsers_num-1] = x;\n}\n\nstatic void mpc_stack_parsers_reserve_more(mpc_stack_t *s) {\n  if (s->parsers_num > s->parsers_slots) {\n    s->parsers_slots = ceil((s->parsers_slots+1) * 1.5);\n    s->parsers = realloc(s->parsers, sizeof(mpc_parser_t*) * s->parsers_slots);\n    s->states = realloc(s->states, sizeof(int) * s->parsers_slots);\n  }\n}\n\nstatic void mpc_stack_parsers_reserve_less(mpc_stack_t *s) {\n  if (s->parsers_slots > pow(s->parsers_num+1, 1.5)) {\n    s->parsers_slots = floor((s->parsers_slots-1) * (1.0/1.5));\n    s->parsers = realloc(s->parsers, sizeof(mpc_parser_t*) * s->parsers_slots);\n    s->states = realloc(s->states, sizeof(int) * s->parsers_slots);\n  }\n}\n\nstatic void mpc_stack_pushp(mpc_stack_t *s, mpc_parser_t *p) {\n  s->parsers_num++;\n  mpc_stack_parsers_reserve_more(s);\n  s->parsers[s->parsers_num-1] = p;\n  s->states[s->parsers_num-1] = 0;\n}\n\nstatic void mpc_stack_popp(mpc_stack_t *s, mpc_parser_t **p, int *st) {\n  *p = s->parsers[s->parsers_num-1];\n  *st = s->states[s->parsers_num-1];\n  s->parsers_num--;\n  mpc_stack_parsers_reserve_less(s);\n}\n\nstatic void mpc_stack_peepp(mpc_stack_t *s, mpc_parser_t **p, int *st) {\n  *p = s->parsers[s->parsers_num-1];\n  *st = s->states[s->parsers_num-1];\n}\n\nstatic int mpc_stack_empty(mpc_stack_t *s) {\n  return s->parsers_num == 0;\n}\n\n/* Stack Result Stuff */\n\nstatic mpc_result_t mpc_result_err(mpc_err_t *e) {\n  mpc_result_t r;\n  r.error = e;\n  return r;\n}\n\nstatic mpc_result_t mpc_result_out(mpc_val_t *x) {\n  mpc_result_t r;\n  r.output = x;\n  return r;\n}\n\nstatic void mpc_stack_results_reserve_more(mpc_stack_t *s) {\n  if (s->results_num > s->results_slots) {\n    s->results_slots = ceil((s->results_slots + 1) * 1.5);\n    s->results = realloc(s->results, sizeof(mpc_result_t) * s->results_slots);\n    s->returns = realloc(s->returns, sizeof(int) * s->results_slots);\n  }\n}\n\nstatic void mpc_stack_results_reserve_less(mpc_stack_t *s) {\n  if ( s->results_slots > pow(s->results_num+1, 1.5)) {\n    s->results_slots = floor((s->results_slots-1) * (1.0/1.5));\n    s->results = realloc(s->results, sizeof(mpc_result_t) * s->results_slots);\n    s->returns = realloc(s->returns, sizeof(int) * s->results_slots);\n  }\n}\n\nstatic void mpc_stack_pushr(mpc_stack_t *s, mpc_result_t x, int r) {\n  s->results_num++;\n  mpc_stack_results_reserve_more(s);\n  s->results[s->results_num-1] = x;\n  s->returns[s->results_num-1] = r;\n}\n\nstatic int mpc_stack_popr(mpc_stack_t *s, mpc_result_t *x) {\n  int r;\n  *x = s->results[s->results_num-1];\n  r = s->returns[s->results_num-1];\n  s->results_num--;\n  mpc_stack_results_reserve_less(s);\n  return r;\n}\n\nstatic int mpc_stack_peekr(mpc_stack_t *s, mpc_result_t *x) {\n  *x = s->results[s->results_num-1];\n  return s->returns[s->results_num-1];\n}\n\nstatic void mpc_stack_popr_err(mpc_stack_t *s, int n) {\n  mpc_result_t x;\n  while (n) {\n    mpc_stack_popr(s, &x);\n    mpc_stack_err(s, x.error);\n    n--;\n  }\n}\n\nstatic void mpc_stack_popr_out(mpc_stack_t *s, int n, mpc_dtor_t *ds) {\n  mpc_result_t x;\n  while (n) {\n    mpc_stack_popr(s, &x);\n    ds[n-1](x.output);\n    n--;\n  }\n}\n\nstatic void mpc_stack_popr_out_single(mpc_stack_t *s, int n, mpc_dtor_t dx) {\n  mpc_result_t x;\n  while (n) {\n    mpc_stack_popr(s, &x);\n    dx(x.output);\n    n--;\n  }\n}\n\nstatic void mpc_stack_popr_n(mpc_stack_t *s, int n) {\n  mpc_result_t x;\n  while (n) {\n    mpc_stack_popr(s, &x);\n    n--;\n  }\n}\n\nstatic mpc_val_t *mpc_stack_merger_out(mpc_stack_t *s, int n, mpc_fold_t f) {\n  mpc_val_t *x = f(n, (mpc_val_t**)(&s->results[s->results_num-n]));\n  mpc_stack_popr_n(s, n);\n  return x;\n}\n\nstatic mpc_err_t *mpc_stack_merger_err(mpc_stack_t *s, int n) {\n  mpc_err_t *x = mpc_err_or((mpc_err_t**)(&s->results[s->results_num-n]), n);\n  mpc_stack_popr_n(s, n);\n  return x;\n}\n\n/*\n** This is rather pleasant. The core parsing routine\n** is written in about 200 lines of C.\n**\n** I also love the way in which each parsing type\n** concisely matches some construct or pattern.\n**\n** Particularly nice are the `or` and `and`\n** types which have a broken but mirrored structure\n** with return value and error reflected.\n**\n** When this function was written in recursive form\n** it looked pretty nice. But I've since switched\n** it around to an awkward while loop. It was an\n** unfortunate change for code simplicity but it\n** is noble in the name of performance (and \n** not smashing the stack).\n**\n** But it is now a pretty ugly beast...\n*/\n\n#define MPC_CONTINUE(st, x) mpc_stack_set_state(stk, st); mpc_stack_pushp(stk, x); continue\n#define MPC_SUCCESS(x) mpc_stack_popp(stk, &p, &st); mpc_stack_pushr(stk, mpc_result_out(x), 1); continue\n#define MPC_FAILURE(x) mpc_stack_popp(stk, &p, &st); mpc_stack_pushr(stk, mpc_result_err(x), 0); continue\n#define MPC_PRIMATIVE(x, f) if (f) { MPC_SUCCESS(x); } else { MPC_FAILURE(mpc_err_fail(i->filename, i->state, \"Incorrect Input\")); }\n\nint mpc_parse_input(mpc_input_t *i, mpc_parser_t *init, mpc_result_t *final) {\n  \n  /* Stack */\n  int st = 0;\n  mpc_parser_t *p = NULL;\n  mpc_stack_t *stk = mpc_stack_new(i->filename);\n  \n  /* Variables */\n  char *s;\n  mpc_result_t r;\n\n  /* Go! */\n  mpc_stack_pushp(stk, init);\n  \n  while (!mpc_stack_empty(stk)) {\n    \n    mpc_stack_peepp(stk, &p, &st);\n    \n    switch (p->type) {\n      \n      /* Basic Parsers */\n\n      case MPC_TYPE_SOI:       MPC_PRIMATIVE(NULL, mpc_input_soi(i));\n      case MPC_TYPE_EOI:       MPC_PRIMATIVE(NULL, mpc_input_eoi(i));\n      case MPC_TYPE_ANY:       MPC_PRIMATIVE(s, mpc_input_any(i, &s));\n      case MPC_TYPE_SINGLE:    MPC_PRIMATIVE(s, mpc_input_char(i, p->data.single.x, &s));\n      case MPC_TYPE_RANGE:     MPC_PRIMATIVE(s, mpc_input_range(i, p->data.range.x, p->data.range.y, &s));\n      case MPC_TYPE_ONEOF:     MPC_PRIMATIVE(s, mpc_input_oneof(i, p->data.string.x, &s));\n      case MPC_TYPE_NONEOF:    MPC_PRIMATIVE(s, mpc_input_noneof(i, p->data.string.x, &s));\n      case MPC_TYPE_SATISFY:   MPC_PRIMATIVE(s, mpc_input_satisfy(i, p->data.satisfy.f, &s));\n      case MPC_TYPE_STRING:    MPC_PRIMATIVE(s, mpc_input_string(i, p->data.string.x, &s));\n      \n      /* Other parsers */\n      \n      case MPC_TYPE_UNDEFINED: MPC_FAILURE(mpc_err_fail(i->filename, i->state, \"Parser Undefined!\"));      \n      case MPC_TYPE_PASS:      MPC_SUCCESS(NULL);\n      case MPC_TYPE_FAIL:      MPC_FAILURE(mpc_err_fail(i->filename, i->state, p->data.fail.m));\n      case MPC_TYPE_LIFT:      MPC_SUCCESS(p->data.lift.lf());\n      case MPC_TYPE_LIFT_VAL:  MPC_SUCCESS(p->data.lift.x);\n      case MPC_TYPE_STATE:     MPC_SUCCESS(mpc_state_copy(i->state));\n      \n      case MPC_TYPE_BOUNDARY:\n\tif (mpc_input_boundary(i)) {\n\t  MPC_SUCCESS(NULL);\n        } else {\n\t  MPC_FAILURE(mpc_err_new(i->filename, i->state, \"boundary\", mpc_input_peekc(i)));\n\t}\n      \n      /* Application Parsers */\n      \n      case MPC_TYPE_EXPECT:\n        if (st == 0) { MPC_CONTINUE(1, p->data.expect.x); }\n        if (st == 1) {\n          if (mpc_stack_popr(stk, &r)) {\n            MPC_SUCCESS(r.output);\n          } else {\n            mpc_err_delete(r.error); \n            MPC_FAILURE(mpc_err_new(i->filename, i->state, p->data.expect.m, mpc_input_peekc(i)));\n          }\n        }\n      \n      case MPC_TYPE_APPLY:\n        if (st == 0) { MPC_CONTINUE(1, p->data.apply.x); }\n        if (st == 1) {\n          if (mpc_stack_popr(stk, &r)) {\n            MPC_SUCCESS(p->data.apply.f(r.output));\n          } else {\n            MPC_FAILURE(r.error);\n          }\n        }\n      \n      case MPC_TYPE_APPLY_TO:\n        if (st == 0) { MPC_CONTINUE(1, p->data.apply_to.x); }\n        if (st == 1) {\n          if (mpc_stack_popr(stk, &r)) {\n            MPC_SUCCESS(p->data.apply_to.f(r.output, p->data.apply_to.d));\n          } else {\n            MPC_FAILURE(r.error);\n          }\n        }\n      \n      case MPC_TYPE_PREDICT:\n        if (st == 0) { mpc_input_backtrack_disable(i); MPC_CONTINUE(1, p->data.predict.x); }\n        if (st == 1) {\n          mpc_input_backtrack_enable(i);\n          mpc_stack_popp(stk, &p, &st);\n          continue;\n        }\n      \n      /* Optional Parsers */\n      \n      /* TODO: Update Not Error Message */\n      \n      case MPC_TYPE_NOT:\n        if (st == 0) { mpc_input_mark(i); MPC_CONTINUE(1, p->data.not.x); }\n        if (st == 1) {\n          if (mpc_stack_popr(stk, &r)) {\n            mpc_input_rewind(i);\n            p->data.not.dx(r.output);\n            MPC_FAILURE(mpc_err_new(i->filename, i->state, \"opposite\", mpc_input_peekc(i)));\n          } else {\n            mpc_input_unmark(i);\n            mpc_stack_err(stk, r.error);\n            MPC_SUCCESS(p->data.not.lf());\n          }\n        }\n      \n      case MPC_TYPE_MAYBE:\n        if (st == 0) { MPC_CONTINUE(1, p->data.not.x); }\n        if (st == 1) {\n          if (mpc_stack_popr(stk, &r)) {\n            MPC_SUCCESS(r.output);\n          } else {\n            mpc_stack_err(stk, r.error);\n            MPC_SUCCESS(p->data.not.lf());\n          }\n        }\n      \n      /* Repeat Parsers */\n      \n      case MPC_TYPE_MANY:\n        if (st == 0) { MPC_CONTINUE(st+1, p->data.repeat.x); }\n        if (st >  0) {\n          if (mpc_stack_peekr(stk, &r)) {\n            MPC_CONTINUE(st+1, p->data.repeat.x);\n          } else {\n            mpc_stack_popr(stk, &r);\n            mpc_stack_err(stk, r.error);\n            MPC_SUCCESS(mpc_stack_merger_out(stk, st-1, p->data.repeat.f));\n          }\n        }\n      \n      case MPC_TYPE_MANY1:\n        if (st == 0) { MPC_CONTINUE(st+1, p->data.repeat.x); }\n        if (st >  0) {\n          if (mpc_stack_peekr(stk, &r)) {\n            MPC_CONTINUE(st+1, p->data.repeat.x);\n          } else {\n            if (st == 1) {\n              mpc_stack_popr(stk, &r);\n              MPC_FAILURE(mpc_err_many1(r.error));\n            } else {\n              mpc_stack_popr(stk, &r);\n              mpc_stack_err(stk, r.error);\n              MPC_SUCCESS(mpc_stack_merger_out(stk, st-1, p->data.repeat.f));\n            }\n          }\n        }\n      \n      case MPC_TYPE_COUNT:\n        if (st == 0) { mpc_input_mark(i); MPC_CONTINUE(st+1, p->data.repeat.x); }\n        if (st >  0) {\n          if (mpc_stack_peekr(stk, &r)) {\n            MPC_CONTINUE(st+1, p->data.repeat.x);\n          } else {\n            if (st != (p->data.repeat.n+1)) {\n              mpc_stack_popr(stk, &r);\n              mpc_stack_popr_out_single(stk, st-1, p->data.repeat.dx);\n              mpc_input_rewind(i);\n              MPC_FAILURE(mpc_err_count(r.error, p->data.repeat.n));\n            } else {\n              mpc_stack_popr(stk, &r);\n              mpc_stack_err(stk, r.error);\n              mpc_input_unmark(i);\n              MPC_SUCCESS(mpc_stack_merger_out(stk, st-1, p->data.repeat.f));\n            }\n          }\n        }\n        \n      /* Combinatory Parsers */\n      \n      case MPC_TYPE_OR:\n        \n        if (p->data.or.n == 0) { MPC_SUCCESS(NULL); }\n        \n        if (st == 0) { MPC_CONTINUE(st+1, p->data.or.xs[st]); }\n        if (st <= p->data.or.n) {\n          if (mpc_stack_peekr(stk, &r)) {\n            mpc_stack_popr(stk, &r);\n            mpc_stack_popr_err(stk, st-1);\n            MPC_SUCCESS(r.output);\n          }\n          if (st <  p->data.or.n) { MPC_CONTINUE(st+1, p->data.or.xs[st]); }\n          if (st == p->data.or.n) { MPC_FAILURE(mpc_stack_merger_err(stk, p->data.or.n)); }\n        }\n      \n      case MPC_TYPE_AND:\n        \n        if (p->data.or.n == 0) { MPC_SUCCESS(p->data.and.f(0, NULL)); }\n        \n        if (st == 0) { mpc_input_mark(i); MPC_CONTINUE(st+1, p->data.and.xs[st]); }\n        if (st <= p->data.and.n) {\n          if (!mpc_stack_peekr(stk, &r)) {\n            mpc_input_rewind(i);\n            mpc_stack_popr(stk, &r);\n            mpc_stack_popr_out(stk, st-1, p->data.and.dxs);\n            MPC_FAILURE(r.error);\n          }\n          if (st <  p->data.and.n) { MPC_CONTINUE(st+1, p->data.and.xs[st]); }\n          if (st == p->data.and.n) { mpc_input_unmark(i); MPC_SUCCESS(mpc_stack_merger_out(stk, p->data.and.n, p->data.and.f)); }\n        }\n      \n      /* End */\n      \n      default:\n        \n        MPC_FAILURE(mpc_err_fail(i->filename, i->state, \"Unknown Parser Type Id!\"));\n    }\n  }\n  \n  return mpc_stack_terminate(stk, final);\n  \n}\n\n#undef MPC_CONTINUE\n#undef MPC_SUCCESS\n#undef MPC_FAILURE\n#undef MPC_PRIMATIVE\n\nint mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r) {\n  int x;\n  mpc_input_t *i = mpc_input_new_string(filename, string);\n  x = mpc_parse_input(i, p, r);\n  mpc_input_delete(i);\n  return x;\n}\n\nint mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r) {\n  int x;\n  mpc_input_t *i = mpc_input_new_file(filename, file);\n  x = mpc_parse_input(i, p, r);\n  mpc_input_delete(i);\n  return x;\n}\n\nint mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r) {\n  int x;\n  mpc_input_t *i = mpc_input_new_pipe(filename, pipe);\n  x = mpc_parse_input(i, p, r);\n  mpc_input_delete(i);\n  return x;\n}\n\nint mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r) {\n  \n  FILE *f = fopen(filename, \"rb\");\n  int res;\n  \n  if (f == NULL) {\n    r->output = NULL;\n    r->error = mpc_err_fail(filename, mpc_state_new(), \"Unable to open file!\");\n    return 0;\n  }\n  \n  res = mpc_parse_file(filename, f, p, r);\n  fclose(f);\n  return res;\n}\n\n/*\n** Building a Parser\n*/\n\nstatic void mpc_undefine_unretained(mpc_parser_t *p, int force);\n\nstatic void mpc_undefine_or(mpc_parser_t *p) {\n  \n  int i;\n  for (i = 0; i < p->data.or.n; i++) {\n    mpc_undefine_unretained(p->data.or.xs[i], 0);\n  }\n  free(p->data.or.xs);\n  \n}\n\nstatic void mpc_undefine_and(mpc_parser_t *p) {\n  \n  int i;\n  for (i = 0; i < p->data.and.n; i++) {\n    mpc_undefine_unretained(p->data.and.xs[i], 0);\n  }\n  free(p->data.and.xs);\n  free(p->data.and.dxs);\n  \n}\n\nstatic void mpc_undefine_unretained(mpc_parser_t *p, int force) {\n  \n  if (p->retained && !force) { return; }\n  \n  switch (p->type) {\n    \n    case MPC_TYPE_FAIL: free(p->data.fail.m); break;\n    \n    case MPC_TYPE_ONEOF: \n    case MPC_TYPE_NONEOF:\n    case MPC_TYPE_STRING:\n      free(p->data.string.x); \n      break;\n    \n    case MPC_TYPE_APPLY:    mpc_undefine_unretained(p->data.apply.x, 0);    break;\n    case MPC_TYPE_APPLY_TO: mpc_undefine_unretained(p->data.apply_to.x, 0); break;\n    case MPC_TYPE_PREDICT:  mpc_undefine_unretained(p->data.predict.x, 0);  break;\n    \n    case MPC_TYPE_MAYBE:\n    case MPC_TYPE_NOT:\n      mpc_undefine_unretained(p->data.not.x, 0);\n      break;\n    \n    case MPC_TYPE_EXPECT:\n      mpc_undefine_unretained(p->data.expect.x, 0);\n      free(p->data.expect.m);\n      break;\n      \n    case MPC_TYPE_MANY:\n    case MPC_TYPE_MANY1:\n    case MPC_TYPE_COUNT:\n      mpc_undefine_unretained(p->data.repeat.x, 0);\n      break;\n    \n    case MPC_TYPE_OR:  mpc_undefine_or(p);  break;\n    case MPC_TYPE_AND: mpc_undefine_and(p); break;\n    \n    default: break;\n  }\n  \n  if (!force) {\n    free(p->name);\n    free(p);\n  }\n  \n}\n\nvoid mpc_delete(mpc_parser_t *p) {\n  if (p->retained) {\n\n    if (p->type != MPC_TYPE_UNDEFINED) {\n      mpc_undefine_unretained(p, 0);\n    } \n    \n    free(p->name);\n    free(p);\n  \n  } else {\n    mpc_undefine_unretained(p, 0);  \n  }\n}\n\nstatic void mpc_soft_delete(mpc_val_t *x) {\n  mpc_undefine_unretained(x, 0);\n}\n\nstatic mpc_parser_t *mpc_undefined(void) {\n  mpc_parser_t *p = calloc(1, sizeof(mpc_parser_t));\n  p->retained = 0;\n  p->type = MPC_TYPE_UNDEFINED;\n  p->name = NULL;\n  return p;\n}\n\nmpc_parser_t *mpc_new(const char *name) {\n  mpc_parser_t *p = mpc_undefined();\n  p->retained = 1;\n  p->name = realloc(p->name, strlen(name) + 1);\n  strcpy(p->name, name);\n  return p;\n}\n\nmpc_parser_t *mpc_undefine(mpc_parser_t *p) {\n  mpc_undefine_unretained(p, 1);\n  p->type = MPC_TYPE_UNDEFINED;\n  return p;\n}\n\nmpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a) {\n  \n  if (p->retained) {\n    p->type = a->type;\n    p->data = a->data;\n  } else {\n    mpc_parser_t *a2 = mpc_failf(\"Attempt to assign to Unretained Parser!\");\n    p->type = a2->type;\n    p->data = a2->data;\n    free(a2);\n  }\n  \n  free(a);\n  return p;  \n}\n\nvoid mpc_cleanup(int n, ...) {\n  int i;\n  mpc_parser_t **list = malloc(sizeof(mpc_parser_t*) * n);\n  \n  va_list va;\n  va_start(va, n);\n  for (i = 0; i < n; i++) { list[i] = va_arg(va, mpc_parser_t*); }\n  for (i = 0; i < n; i++) { mpc_undefine(list[i]); }\n  for (i = 0; i < n; i++) { mpc_delete(list[i]); }  \n  va_end(va);  \n\n  free(list);\n}\n\nmpc_parser_t *mpc_pass(void) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_PASS;\n  return p;\n}\n\nmpc_parser_t *mpc_fail(const char *m) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_FAIL;\n  p->data.fail.m = malloc(strlen(m) + 1);\n  strcpy(p->data.fail.m, m);\n  return p;\n}\n\n/*\n** As `snprintf` is not ANSI standard this \n** function `mpc_failf` should be considered\n** unsafe.\n**\n** You have a few options if this is going to be\n** trouble.\n**\n** - Ensure the format string does not exceed\n**   the buffer length using precision specifiers\n**   such as `%.512s`.\n**\n** - Patch this function in your code base to \n**   use `snprintf` or whatever variant your\n**   system supports.\n**\n** - Avoid it altogether.\n**\n*/\n\nmpc_parser_t *mpc_failf(const char *fmt, ...) {\n  \n  va_list va;\n  char *buffer;\n\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_FAIL;\n  \n  va_start(va, fmt);\n  buffer = malloc(2048);\n  vsprintf(buffer, fmt, va);\n  va_end(va);\n  \n  buffer = realloc(buffer, strlen(buffer) + 1);\n  p->data.fail.m = buffer;\n  return p;\n\n}\n\nmpc_parser_t *mpc_lift_val(mpc_val_t *x) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_LIFT_VAL;\n  p->data.lift.x = x;\n  return p;\n}\n\nmpc_parser_t *mpc_lift(mpc_ctor_t lf) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_LIFT;\n  p->data.lift.lf = lf;\n  return p;\n}\n\nmpc_parser_t *mpc_state(void) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_STATE;\n  return p;\n}\n\nmpc_parser_t *mpc_boundary(void) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_BOUNDARY;\n  return p;\n}\n\nmpc_parser_t *mpc_expect(mpc_parser_t *a, const char *expected) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_EXPECT;\n  p->data.expect.x = a;\n  p->data.expect.m = malloc(strlen(expected) + 1);\n  strcpy(p->data.expect.m, expected);\n  return p;\n}\n\n/*\n** As `snprintf` is not ANSI standard this \n** function `mpc_expectf` should be considered\n** unsafe.\n**\n** You have a few options if this is going to be\n** trouble.\n**\n** - Ensure the format string does not exceed\n**   the buffer length using precision specifiers\n**   such as `%.512s`.\n**\n** - Patch this function in your code base to \n**   use `snprintf` or whatever variant your\n**   system supports.\n**\n** - Avoid it altogether.\n**\n*/\n\nmpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...) {\n  va_list va;\n  char *buffer;\n\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_EXPECT;\n  \n  va_start(va, fmt);\n  buffer = malloc(2048);\n  vsprintf(buffer, fmt, va);\n  va_end(va);\n  \n  buffer = realloc(buffer, strlen(buffer) + 1);\n  p->data.expect.x = a;\n  p->data.expect.m = buffer;\n  return p;\n}\n\n/*\n** Basic Parsers\n*/\n\nmpc_parser_t *mpc_any(void) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_ANY;\n  return mpc_expect(p, \"any character\");\n}\n\nmpc_parser_t *mpc_char(char c) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_SINGLE;\n  p->data.single.x = c;\n  return mpc_expectf(p, \"'%c'\", c);\n}\n\nmpc_parser_t *mpc_range(char s, char e) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_RANGE;\n  p->data.range.x = s;\n  p->data.range.y = e;\n  return mpc_expectf(p, \"character between '%c' and '%c'\", s, e);\n}\n\nmpc_parser_t *mpc_oneof(const char *s) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_ONEOF;\n  p->data.string.x = malloc(strlen(s) + 1);\n  strcpy(p->data.string.x, s);\n  return mpc_expectf(p, \"one of '%s'\", s);\n}\n\nmpc_parser_t *mpc_noneof(const char *s) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_NONEOF;\n  p->data.string.x = malloc(strlen(s) + 1);\n  strcpy(p->data.string.x, s);\n  return mpc_expectf(p, \"one of '%s'\", s);\n\n}\n\nmpc_parser_t *mpc_satisfy(int(*f)(char)) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_SATISFY;\n  p->data.satisfy.f = f;\n  return mpc_expectf(p, \"character satisfying function %p\", f);\n}\n\nmpc_parser_t *mpc_string(const char *s) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_STRING;\n  p->data.string.x = malloc(strlen(s) + 1);\n  strcpy(p->data.string.x, s);\n  return mpc_expectf(p, \"\\\"%s\\\"\", s);\n}\n\n/*\n** Core Parsers\n*/\n\nmpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_APPLY;\n  p->data.apply.x = a;\n  p->data.apply.f = f;\n  return p;\n}\n\nmpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_APPLY_TO;\n  p->data.apply_to.x = a;\n  p->data.apply_to.f = f;\n  p->data.apply_to.d = x;\n  return p;\n}\n\nmpc_parser_t *mpc_predictive(mpc_parser_t *a) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_PREDICT;\n  p->data.predict.x = a;\n  return p;\n}\n\nmpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_NOT;\n  p->data.not.x = a;\n  p->data.not.dx = da;\n  p->data.not.lf = lf;\n  return p;\n}\n\nmpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da) {\n  return mpc_not_lift(a, da, mpcf_ctor_null);\n}\n\nmpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_MAYBE;\n  p->data.not.x = a;\n  p->data.not.lf = lf;\n  return p;\n}\n\nmpc_parser_t *mpc_maybe(mpc_parser_t *a) {\n  return mpc_maybe_lift(a, mpcf_ctor_null);\n}\n\nmpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_MANY;\n  p->data.repeat.x = a;\n  p->data.repeat.f = f;\n  return p;\n}\n\nmpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_MANY1;\n  p->data.repeat.x = a;\n  p->data.repeat.f = f;\n  return p;\n}\n\nmpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_COUNT;\n  p->data.repeat.n = n;\n  p->data.repeat.f = f;\n  p->data.repeat.x = a;\n  p->data.repeat.dx = da;\n  return p;\n}\n\nmpc_parser_t *mpc_or(int n, ...) {\n\n  int i;\n  va_list va;\n\n  mpc_parser_t *p = mpc_undefined();\n  \n  p->type = MPC_TYPE_OR;\n  p->data.or.n = n;\n  p->data.or.xs = malloc(sizeof(mpc_parser_t*) * n);\n  \n  va_start(va, n);  \n  for (i = 0; i < n; i++) {\n    p->data.or.xs[i] = va_arg(va, mpc_parser_t*);\n  }\n  va_end(va);\n  \n  return p;\n}\n\nmpc_parser_t *mpc_and(int n, mpc_fold_t f, ...) {\n\n  int i;\n  va_list va;\n\n  mpc_parser_t *p = mpc_undefined();\n  \n  p->type = MPC_TYPE_AND;\n  p->data.and.n = n;\n  p->data.and.f = f;\n  p->data.and.xs = malloc(sizeof(mpc_parser_t*) * n);\n  p->data.and.dxs = malloc(sizeof(mpc_dtor_t) * (n-1));\n\n  va_start(va, f);  \n  for (i = 0; i < n; i++) {\n    p->data.and.xs[i] = va_arg(va, mpc_parser_t*);\n  }\n  for (i = 0; i < (n-1); i++) {\n    p->data.and.dxs[i] = va_arg(va, mpc_dtor_t);\n  }  \n  va_end(va);\n  \n  return p;\n}\n\n/*\n** Common Parsers\n*/\n\nmpc_parser_t *mpc_eoi(void) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_EOI;\n  return mpc_expect(p, \"end of input\");\n}\n\nmpc_parser_t *mpc_soi(void) {\n  mpc_parser_t *p = mpc_undefined();\n  p->type = MPC_TYPE_SOI;\n  return mpc_expect(p, \"start of input\");\n}\n\nmpc_parser_t *mpc_whitespace(void) { return mpc_expect(mpc_oneof(\" \\f\\n\\r\\t\\v\"), \"whitespace\"); }\nmpc_parser_t *mpc_whitespaces(void) { return mpc_expect(mpc_many(mpcf_strfold, mpc_whitespace()), \"spaces\"); }\nmpc_parser_t *mpc_blank(void) { return mpc_expect(mpc_apply(mpc_whitespaces(), mpcf_free), \"whitespace\"); }\n\nmpc_parser_t *mpc_newline(void) { return mpc_expect(mpc_char('\\n'), \"newline\"); }\nmpc_parser_t *mpc_tab(void) { return mpc_expect(mpc_char('\\t'), \"tab\"); }\nmpc_parser_t *mpc_escape(void) { return mpc_and(2, mpcf_strfold, mpc_char('\\\\'), mpc_any(), free); }\n\nmpc_parser_t *mpc_digit(void) { return mpc_expect(mpc_oneof(\"0123456789\"), \"digit\"); }\nmpc_parser_t *mpc_hexdigit(void) { return mpc_expect(mpc_oneof(\"0123456789ABCDEFabcdef\"), \"hex digit\"); }\nmpc_parser_t *mpc_octdigit(void) { return mpc_expect(mpc_oneof(\"01234567\"), \"oct digit\"); }\nmpc_parser_t *mpc_digits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_digit()), \"digits\"); }\nmpc_parser_t *mpc_hexdigits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_hexdigit()), \"hex digits\"); }\nmpc_parser_t *mpc_octdigits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_octdigit()), \"oct digits\"); }\n\nmpc_parser_t *mpc_lower(void) { return mpc_expect(mpc_oneof(\"abcdefghijklmnopqrstuvwxyz\"), \"lowercase letter\"); }\nmpc_parser_t *mpc_upper(void) { return mpc_expect(mpc_oneof(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"uppercase letter\"); }\nmpc_parser_t *mpc_alpha(void) { return mpc_expect(mpc_oneof(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"letter\"); }\nmpc_parser_t *mpc_underscore(void) { return mpc_expect(mpc_char('_'), \"underscore\"); }\nmpc_parser_t *mpc_alphanum(void) { return mpc_expect(mpc_or(3, mpc_alpha(), mpc_digit(), mpc_underscore()), \"alphanumeric\"); }\n\nmpc_parser_t *mpc_int(void) { return mpc_expect(mpc_apply(mpc_digits(), mpcf_int), \"integer\"); }\nmpc_parser_t *mpc_hex(void) { return mpc_expect(mpc_apply(mpc_hexdigits(), mpcf_hex), \"hexadecimal\"); }\nmpc_parser_t *mpc_oct(void) { return mpc_expect(mpc_apply(mpc_octdigits(), mpcf_oct), \"octadecimal\"); }\nmpc_parser_t *mpc_number(void) { return mpc_expect(mpc_or(3, mpc_int(), mpc_hex(), mpc_oct()), \"number\"); }\n\nmpc_parser_t *mpc_real(void) {\n\n  /* [+-]?\\d+(\\.\\d+)?([eE][+-]?[0-9]+)? */\n  \n  mpc_parser_t *p0, *p1, *p2, *p30, *p31, *p32, *p3;\n  \n  p0 = mpc_maybe_lift(mpc_oneof(\"+-\"), mpcf_ctor_str);\n  p1 = mpc_digits();\n  p2 = mpc_maybe_lift(mpc_and(2, mpcf_strfold, mpc_char('.'), mpc_digits(), free), mpcf_ctor_str);\n  p30 = mpc_oneof(\"eE\");\n  p31 = mpc_maybe_lift(mpc_oneof(\"+-\"), mpcf_ctor_str);\n  p32 = mpc_digits();\n  p3 = mpc_maybe_lift(mpc_and(3, mpcf_strfold, p30, p31, p32, free, free), mpcf_ctor_str);\n  \n  return mpc_expect(mpc_and(4, mpcf_strfold, p0, p1, p2, p3, free, free, free), \"real\");\n\n}\n\nmpc_parser_t *mpc_float(void) {\n  return mpc_expect(mpc_apply(mpc_real(), mpcf_float), \"float\");\n}\n\nmpc_parser_t *mpc_char_lit(void) {\n  return mpc_expect(mpc_between(mpc_or(2, mpc_escape(), mpc_any()), free, \"'\", \"'\"), \"char\");\n}\n\nmpc_parser_t *mpc_string_lit(void) {\n  mpc_parser_t *strchar = mpc_or(2, mpc_escape(), mpc_noneof(\"\\\"\"));\n  return mpc_expect(mpc_between(mpc_many(mpcf_strfold, strchar), free, \"\\\"\", \"\\\"\"), \"string\");\n}\n\nmpc_parser_t *mpc_regex_lit(void) {  \n  mpc_parser_t *regexchar = mpc_or(2, mpc_escape(), mpc_noneof(\"/\"));\n  return mpc_expect(mpc_between(mpc_many(mpcf_strfold, regexchar), free, \"/\", \"/\"), \"regex\");\n}\n\nmpc_parser_t *mpc_ident(void) {\n  mpc_parser_t *p0, *p1; \n  p0 = mpc_or(2, mpc_alpha(), mpc_underscore());\n  p1 = mpc_many(mpcf_strfold, mpc_alphanum()); \n  return mpc_and(2, mpcf_strfold, p0, p1, free);\n}\n\n/*\n** Useful Parsers\n*/\n\nmpc_parser_t *mpc_startwith(mpc_parser_t *a) { return mpc_and(2, mpcf_snd, mpc_soi(), a, mpcf_dtor_null); }\nmpc_parser_t *mpc_endwith(mpc_parser_t *a, mpc_dtor_t da) { return mpc_and(2, mpcf_fst, a, mpc_eoi(), da); }\nmpc_parser_t *mpc_whole(mpc_parser_t *a, mpc_dtor_t da) { return mpc_and(3, mpcf_snd, mpc_soi(), a, mpc_eoi(), mpcf_dtor_null, da); }\n\nmpc_parser_t *mpc_stripl(mpc_parser_t *a) { return mpc_and(2, mpcf_snd, mpc_blank(), a, mpcf_dtor_null); }\nmpc_parser_t *mpc_stripr(mpc_parser_t *a) { return mpc_and(2, mpcf_fst, a, mpc_blank(), mpcf_dtor_null); }\nmpc_parser_t *mpc_strip(mpc_parser_t *a) { return mpc_and(3, mpcf_snd, mpc_blank(), a, mpc_blank(), mpcf_dtor_null, mpcf_dtor_null); }\nmpc_parser_t *mpc_tok(mpc_parser_t *a) { return mpc_and(2, mpcf_fst, a, mpc_blank(), mpcf_dtor_null); }\nmpc_parser_t *mpc_sym(const char *s) { return mpc_tok(mpc_string(s)); }\n\nmpc_parser_t *mpc_total(mpc_parser_t *a, mpc_dtor_t da) { return mpc_whole(mpc_strip(a), da); }\n\nmpc_parser_t *mpc_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c) {\n  return mpc_and(3, mpcf_snd_free,\n    mpc_string(o), a, mpc_string(c),\n    free, ad);\n}\n\nmpc_parser_t *mpc_parens(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_between(a, ad, \"(\", \")\"); }\nmpc_parser_t *mpc_braces(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_between(a, ad, \"<\", \">\"); }\nmpc_parser_t *mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad) { return mpc_between(a, ad, \"{\", \"}\"); }\nmpc_parser_t *mpc_squares(mpc_parser_t *a, mpc_dtor_t ad)  { return mpc_between(a, ad, \"[\", \"]\"); }\n\nmpc_parser_t *mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c) {\n  return mpc_and(3, mpcf_snd_free,\n    mpc_sym(o), mpc_tok(a), mpc_sym(c),\n    free, ad);\n}\n\nmpc_parser_t *mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_tok_between(a, ad, \"(\", \")\"); }\nmpc_parser_t *mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_tok_between(a, ad, \"<\", \">\"); }\nmpc_parser_t *mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad) { return mpc_tok_between(a, ad, \"{\", \"}\"); }\nmpc_parser_t *mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad)  { return mpc_tok_between(a, ad, \"[\", \"]\"); }\n\n/*\n** Regular Expression Parsers\n*/\n\n/*\n** So here is a cute bootstrapping.\n**\n** I'm using the previously defined\n** mpc constructs and functions to\n** parse the user regex string and\n** construct a parser from it.\n**\n** As it turns out lots of the standard\n** mpc functions look a lot like `fold`\n** functions and so can be used indirectly\n** by many of the parsing functions to build\n** a parser directly - as we are parsing.\n**\n** This is certainly something that\n** would be less elegant/interesting \n** in a two-phase parser which first\n** builds an AST and then traverses it\n** to generate the object.\n**\n** This whole thing acts as a great\n** case study for how trivial it can be\n** to write a great parser in a few\n** lines of code using mpc.\n*/\n\n/*\n**\n**  ### Regular Expression Grammar\n**\n**      <regex> : <term> | (<term> \"|\" <regex>)\n**     \n**      <term> : <factor>*\n**\n**      <factor> : <base>\n**               | <base> \"*\"\n**               | <base> \"+\"\n**               | <base> \"?\"\n**               | <base> \"{\" <digits> \"}\"\n**           \n**      <base> : <char>\n**             | \"\\\" <char>\n**             | \"(\" <regex> \")\"\n**             | \"[\" <range> \"]\"\n*/\n\nstatic mpc_val_t *mpcf_re_or(int n, mpc_val_t **xs) {\n  if (xs[1] == NULL) { return xs[0]; }\n  else { return mpc_or(2, xs[0], xs[1]); }\n}\n\nstatic mpc_val_t *mpcf_re_and(int n, mpc_val_t **xs) {\n  int i;\n  mpc_parser_t *p = mpc_lift(mpcf_ctor_str);\n  for (i = 0; i < n; i++) {\n    p = mpc_and(2, mpcf_strfold, p, xs[i], free);\n  }\n  return p;\n}\n\nstatic mpc_val_t *mpcf_re_repeat(int n, mpc_val_t **xs) {\n  \n  int num;\n  if (xs[1] == NULL) { return xs[0]; }\n  if (strcmp(xs[1], \"*\") == 0) { free(xs[1]); return mpc_many(mpcf_strfold, xs[0]); }\n  if (strcmp(xs[1], \"+\") == 0) { free(xs[1]); return mpc_many1(mpcf_strfold, xs[0]); }\n  if (strcmp(xs[1], \"?\") == 0) { free(xs[1]); return mpc_maybe_lift(xs[0], mpcf_ctor_str); }\n  num = *(int*)xs[1];\n  free(xs[1]);\n  \n  return mpc_count(num, mpcf_strfold, xs[0], free);\n}\n\nstatic mpc_parser_t *mpc_re_escape_char(char c) {\n  switch (c) {\n    case 'a': return mpc_char('\\a');\n    case 'f': return mpc_char('\\f');\n    case 'n': return mpc_char('\\n');\n    case 'r': return mpc_char('\\r');\n    case 't': return mpc_char('\\t');\n    case 'v': return mpc_char('\\v');\n    case 'b': return mpc_and(2, mpcf_snd, mpc_boundary(), mpc_lift(mpcf_ctor_str), free);\n    case 'B': return mpc_not_lift(mpc_boundary(), free, mpcf_ctor_str);\n    case 'A': return mpc_and(2, mpcf_snd, mpc_soi(), mpc_lift(mpcf_ctor_str), free);\n    case 'Z': return mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free);\n    case 'd': return mpc_digit();\n    case 'D': return mpc_not_lift(mpc_digit(), free, mpcf_ctor_str);\n    case 's': return mpc_whitespace();\n    case 'S': return mpc_not_lift(mpc_whitespace(), free, mpcf_ctor_str);\n    case 'w': return mpc_alphanum();\n    case 'W': return mpc_not_lift(mpc_alphanum(), free, mpcf_ctor_str);\n    default: return NULL;\n  }\n}\n\nstatic mpc_val_t *mpcf_re_escape(mpc_val_t *x) {\n  \n  char *s = x;\n  mpc_parser_t *p;\n  \n  /* Regex Special Characters */\n  if (s[0] == '.') { free(s); return mpc_any(); }\n  if (s[0] == '^') { free(s); return mpc_and(2, mpcf_snd, mpc_soi(), mpc_lift(mpcf_ctor_str), free); }\n  if (s[0] == '$') { free(s); return mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free); }\n  \n  /* Regex Escape */\n  if (s[0] == '\\\\') {\n    p = mpc_re_escape_char(s[1]);\n    p = (p == NULL) ? mpc_char(s[1]) : p;\n    free(s);\n    return p;\n  }\n  \n  /* Regex Standard */\n  p = mpc_char(s[0]);\n  free(s);\n  return p;\n}\n\nstatic char *mpc_re_range_escape_char(char c) {\n  switch (c) {\n    case '-': return \"-\";\n    case 'a': return \"\\a\";\n    case 'f': return \"\\f\";\n    case 'n': return \"\\n\";\n    case 'r': return \"\\r\";\n    case 't': return \"\\t\";\n    case 'v': return \"\\v\";\n    case 'b': return \"\\b\";\n    case 'd': return \"0123456789\";\n    case 's': return \" \\f\\n\\r\\t\\v\";\n    case 'w': return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n    default: return NULL;\n  }\n}\n\nstatic mpc_val_t *mpcf_re_range(mpc_val_t *x) {\n  \n  mpc_parser_t *out;\n  char *range = calloc(1,1);\n  char *tmp = NULL;\n  char *s = x;\n  char start, end;\n  int i, j;\n  int comp = 0;\n  \n  if (s[0] == '\\0') { free(x); return mpc_fail(\"Invalid Regex Range Expression\"); } \n  if (s[0] == '^' && \n      s[1] == '\\0') { free(x); return mpc_fail(\"Invalid Regex Range Expression\"); }\n  \n  if (s[0] == '^') { comp = 1;}\n  \n  for (i = comp; i < strlen(s); i++){\n    \n    /* Regex Range Escape */\n    if (s[i] == '\\\\') {\n      tmp = mpc_re_range_escape_char(s[i+1]);\n      if (tmp != NULL) {\n        range = realloc(range, strlen(range) + strlen(tmp) + 1);\n        strcat(range, tmp);\n      } else {\n        range = realloc(range, strlen(range) + 1 + 1);\n        range[strlen(range) + 1] = '\\0';\n        range[strlen(range) + 0] = s[i+1];      \n      }\n      i++;\n    }\n    \n    /* Regex Range...Range */\n    else if (s[i] == '-') {\n      if (s[i+1] == '\\0' || i == 0) {\n          range = realloc(range, strlen(range) + strlen(\"-\") + 1);\n          strcat(range, \"-\");\n      } else {\n        start = s[i-1]+1;\n        end = s[i+1]-1;\n        for (j = start; j <= end; j++) {\n          range = realloc(range, strlen(range) + 1 + 1);\n          range[strlen(range) + 1] = '\\0';\n          range[strlen(range) + 0] = j;\n        }        \n      }\n    }\n    \n    /* Regex Range Normal */\n    else {\n      range = realloc(range, strlen(range) + 1 + 1);\n      range[strlen(range) + 1] = '\\0';\n      range[strlen(range) + 0] = s[i];\n    }\n  \n  }\n  \n  out = comp ? mpc_noneof(range) : mpc_oneof(range);\n  \n  free(x);\n  free(range);\n  \n  return out;\n}\n\nmpc_parser_t *mpc_re(const char *re) {\n  \n  char *err_msg;\n  mpc_parser_t *err_out;\n  mpc_result_t r;\n  mpc_parser_t *Regex, *Term, *Factor, *Base, *Range, *RegexEnclose; \n  \n  Regex  = mpc_new(\"regex\");\n  Term   = mpc_new(\"term\");\n  Factor = mpc_new(\"factor\");\n  Base   = mpc_new(\"base\");\n  Range  = mpc_new(\"range\");\n  \n  mpc_define(Regex, mpc_and(2, \n    mpcf_re_or,\n    Term, \n    mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_char('|'), Regex, free)),\n    (mpc_dtor_t)mpc_delete\n  ));\n  \n  mpc_define(Term, mpc_many(mpcf_re_and, Factor));\n  \n  mpc_define(Factor, mpc_and(2, \n    mpcf_re_repeat,\n    Base,\n    mpc_or(5,\n      mpc_char('*'), mpc_char('+'), mpc_char('?'),\n      mpc_brackets(mpc_int(), free),\n      mpc_pass()),\n    (mpc_dtor_t)mpc_delete\n  ));\n  \n  mpc_define(Base, mpc_or(4,\n    mpc_parens(Regex, (mpc_dtor_t)mpc_delete),\n    mpc_squares(Range, (mpc_dtor_t)mpc_delete),\n    mpc_apply(mpc_escape(), mpcf_re_escape),\n    mpc_apply(mpc_noneof(\")|\"), mpcf_re_escape)\n  ));\n  \n  mpc_define(Range, mpc_apply(\n    mpc_many(mpcf_strfold, mpc_or(2, mpc_escape(), mpc_noneof(\"]\"))),\n    mpcf_re_range\n  ));\n  \n  RegexEnclose = mpc_whole(mpc_predictive(Regex), (mpc_dtor_t)mpc_delete);\n  \n  if(!mpc_parse(\"<mpc_re_compiler>\", re, RegexEnclose, &r)) {\n    err_msg = mpc_err_string(r.error);\n    err_out = mpc_failf(\"Invalid Regex: %s\", err_msg);\n    mpc_err_delete(r.error);  \n    free(err_msg);\n    r.output = err_out;\n  }\n  \n  mpc_delete(RegexEnclose);\n  mpc_cleanup(5, Regex, Term, Factor, Base, Range);\n  \n  return r.output;\n  \n}\n\n/*\n** Common Fold Functions\n*/\n\nvoid mpcf_dtor_null(mpc_val_t *x) { return; }\n\nmpc_val_t *mpcf_ctor_null(void) { return NULL; }\nmpc_val_t *mpcf_ctor_str(void) { return calloc(1, 1); }\nmpc_val_t *mpcf_free(mpc_val_t *x) { free(x); return NULL; }\n\nmpc_val_t *mpcf_int(mpc_val_t *x) {\n  int *y = malloc(sizeof(int));\n  *y = strtol(x, NULL, 10);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_hex(mpc_val_t *x) {\n  int *y = malloc(sizeof(int));\n  *y = strtol(x, NULL, 16);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_oct(mpc_val_t *x) {\n  int *y = malloc(sizeof(int));\n  *y = strtol(x, NULL, 8);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_float(mpc_val_t *x) {\n  float* y = malloc(sizeof(float));\n  *y = strtod(x, NULL);\n  free(x);\n  return y;\n}\n\nstatic char mpc_escape_input_c[]  = {\n  '\\a', '\\b', '\\f', '\\n', '\\r',\n  '\\t', '\\v', '\\\\', '\\'', '\\\"', '\\0'};\n    \nstatic char *mpc_escape_output_c[] = {\n  \"\\\\a\", \"\\\\b\", \"\\\\f\", \"\\\\n\", \"\\\\r\", \"\\\\t\", \n  \"\\\\v\", \"\\\\\\\\\", \"\\\\'\", \"\\\\\\\"\", \"\\\\0\", NULL};\n\nstatic char mpc_escape_input_raw_re[] = { '/' };\nstatic char *mpc_escape_output_raw_re[] = { \"\\\\/\", NULL };\n\nstatic char mpc_escape_input_raw_cstr[] = { '\"' };\nstatic char *mpc_escape_output_raw_cstr[] = { \"\\\\\\\"\", NULL };\n\nstatic char mpc_escape_input_raw_cchar[] = { '\\'' };\nstatic char *mpc_escape_output_raw_cchar[] = { \"\\\\'\", NULL };\n\nstatic mpc_val_t *mpcf_escape_new(mpc_val_t *x, char *input, char **output) {\n  \n  int i;\n  int found;\n  char *s = x;\n  char *y = calloc(1, 1);\n  char buff[2];\n  \n  while (*s) {\n    \n    i = 0;\n    found = 0;\n\n    while (output[i]) {\n      if (*s == input[i]) {\n        y = realloc(y, strlen(y) + strlen(output[i]) + 1);\n        strcat(y, output[i]);\n        found = 1;\n        break;\n      }\n      i++;\n    }\n    \n    if (!found) {\n      y = realloc(y, strlen(y) + 2);\n      buff[0] = *s; buff[1] = '\\0';\n      strcat(y, buff);\n    }\n    \n    s++;\n  }\n  \n  \n  return y;\n}\n\nstatic mpc_val_t *mpcf_unescape_new(mpc_val_t *x, char *input, char **output) {\n  \n  int i;\n  int found = 0;\n  char *s = x;\n  char *y = calloc(1, 1);\n  char buff[2];\n\n  while (*s) {\n    \n    i = 0;\n    found = 0;\n    \n    while (output[i]) {\n      if ((*(s+0)) == output[i][0] &&\n          (*(s+1)) == output[i][1]) {\n        y = realloc(y, strlen(y) + 2);\n        buff[0] = input[i]; buff[1] = '\\0';\n        strcat(y, buff);\n        found = 1;\n        s++;\n        break;\n      }\n      i++;\n    }\n      \n    if (!found) {\n      y = realloc(y, strlen(y) + 2);\n      buff[0] = *s; buff[1] = '\\0';\n      strcat(y, buff);\n    }\n    \n    if (*s == '\\0') { break; }\n    else { s++; }\n  }\n  \n  return y;\n  \n}\n\nmpc_val_t *mpcf_escape(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_c, mpc_escape_output_c);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_unescape(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_c, mpc_escape_output_c);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_unescape_regex(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_re, mpc_escape_output_raw_re);\n  free(x);\n  return y;  \n}\n\nmpc_val_t *mpcf_escape_string_raw(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_cstr, mpc_escape_output_raw_cstr);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_cstr, mpc_escape_output_raw_cstr);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_escape_char_raw(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_cchar, mpc_escape_output_raw_cchar);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x) {\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_cchar, mpc_escape_output_raw_cchar);\n  free(x);\n  return y;\n}\n\nmpc_val_t *mpcf_null(int n, mpc_val_t** xs) { return NULL; }\nmpc_val_t *mpcf_fst(int n, mpc_val_t **xs) { return xs[0]; }\nmpc_val_t *mpcf_snd(int n, mpc_val_t **xs) { return xs[1]; }\nmpc_val_t *mpcf_trd(int n, mpc_val_t **xs) { return xs[2]; }\n\nstatic mpc_val_t *mpcf_nth_free(int n, mpc_val_t **xs, int x) {\n  int i;\n  for (i = 0; i < n; i++) {\n    if (i != x) { free(xs[i]); }\n  }\n  return xs[x];\n}\n \nmpc_val_t *mpcf_fst_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 0); }\nmpc_val_t *mpcf_snd_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 1); }\nmpc_val_t *mpcf_trd_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 2); }\n\nmpc_val_t *mpcf_strfold(int n, mpc_val_t **xs) {\n  char *x = calloc(1, 1);\n  int i;\n  for (i = 0; i < n; i++) {\n    x = realloc(x, strlen(x) + strlen(xs[i]) + 1);\n    strcat(x, xs[i]);\n    free(xs[i]);\n  }\n  return x;\n}\n\nmpc_val_t *mpcf_maths(int n, mpc_val_t **xs) {\n  \n  int **vs = (int**)xs;\n    \n  if (strcmp(xs[1], \"*\") == 0) { *vs[0] *= *vs[2]; }\n  if (strcmp(xs[1], \"/\") == 0) { *vs[0] /= *vs[2]; }\n  if (strcmp(xs[1], \"%\") == 0) { *vs[0] %= *vs[2]; }\n  if (strcmp(xs[1], \"+\") == 0) { *vs[0] += *vs[2]; }\n  if (strcmp(xs[1], \"-\") == 0) { *vs[0] -= *vs[2]; }\n  \n  free(xs[1]); free(xs[2]);\n  \n  return xs[0];\n}\n\n/*\n** Printing\n*/\n\nstatic void mpc_print_unretained(mpc_parser_t *p, int force) {\n  \n  /* TODO: Print Everything Escaped */\n  \n  int i;\n  char *s, *e;\n  char buff[2];\n  \n  if (p->retained && !force) {;\n    if (p->name) { printf(\"<%s>\", p->name); }\n    else { printf(\"<anon>\"); }\n    return;\n  }\n  \n  if (p->type == MPC_TYPE_UNDEFINED) { printf(\"<?>\"); }\n  if (p->type == MPC_TYPE_PASS)   { printf(\"<:>\"); }\n  if (p->type == MPC_TYPE_FAIL)   { printf(\"<!>\"); }\n  if (p->type == MPC_TYPE_LIFT)   { printf(\"<#>\"); }\n  if (p->type == MPC_TYPE_STATE)  { printf(\"<S#>\"); }\n  if (p->type == MPC_TYPE_BOUNDARY)  { printf(\"<\\\\b>\"); }\n  if (p->type == MPC_TYPE_EXPECT) {\n    printf(\"%s\", p->data.expect.m);\n    /*mpc_print_unretained(p->data.expect.x, 0);*/\n  }\n  \n  if (p->type == MPC_TYPE_SOI) { printf(\"<^>\"); }\n  if (p->type == MPC_TYPE_EOI) { printf(\"<$>\"); }\n  \n  if (p->type == MPC_TYPE_ANY) { printf(\"<.>\"); }\n  if (p->type == MPC_TYPE_SATISFY) { printf(\"<f>\"); }\n\n  if (p->type == MPC_TYPE_SINGLE) {\n    buff[0] = p->data.single.x; buff[1] = '\\0';\n    s = mpcf_escape_new(\n      buff,\n      mpc_escape_input_c,\n      mpc_escape_output_c);\n    printf(\"'%s'\", s);\n    free(s);\n  }\n  \n  if (p->type == MPC_TYPE_RANGE) {\n    buff[0] = p->data.range.x; buff[1] = '\\0';\n    s = mpcf_escape_new(\n      buff,\n      mpc_escape_input_c,\n      mpc_escape_output_c);\n    buff[0] = p->data.range.y; buff[1] = '\\0';\n    e = mpcf_escape_new(\n      buff,\n      mpc_escape_input_c,\n      mpc_escape_output_c);\n    printf(\"[%s-%s]\", s, e);\n    free(s);\n    free(e);\n  }\n  \n  if (p->type == MPC_TYPE_ONEOF) {\n    s = mpcf_escape_new(\n      p->data.string.x,\n      mpc_escape_input_c,\n      mpc_escape_output_c);\n    printf(\"[%s]\", s);\n    free(s);\n  }\n  \n  if (p->type == MPC_TYPE_NONEOF) {\n    s = mpcf_escape_new(\n      p->data.string.x,\n      mpc_escape_input_c,\n      mpc_escape_output_c);\n    printf(\"[^%s]\", s);\n    free(s);\n  }\n  \n  if (p->type == MPC_TYPE_STRING) {\n    s = mpcf_escape_new(\n      p->data.string.x,\n      mpc_escape_input_c,\n      mpc_escape_output_c);\n    printf(\"\\\"%s\\\"\", s);\n    free(s);\n  }\n  \n  if (p->type == MPC_TYPE_APPLY)    { mpc_print_unretained(p->data.apply.x, 0); }\n  if (p->type == MPC_TYPE_APPLY_TO) { mpc_print_unretained(p->data.apply_to.x, 0); }\n  if (p->type == MPC_TYPE_PREDICT)  { mpc_print_unretained(p->data.predict.x, 0); }\n\n  if (p->type == MPC_TYPE_NOT)   { mpc_print_unretained(p->data.not.x, 0); printf(\"!\"); }\n  if (p->type == MPC_TYPE_MAYBE) { mpc_print_unretained(p->data.not.x, 0); printf(\"?\"); }\n\n  if (p->type == MPC_TYPE_MANY)  { mpc_print_unretained(p->data.repeat.x, 0); printf(\"*\"); }\n  if (p->type == MPC_TYPE_MANY1) { mpc_print_unretained(p->data.repeat.x, 0); printf(\"+\"); }\n  if (p->type == MPC_TYPE_COUNT) { mpc_print_unretained(p->data.repeat.x, 0); printf(\"{%i}\", p->data.repeat.n); }\n  \n  if (p->type == MPC_TYPE_OR) {\n    printf(\"(\");\n    for(i = 0; i < p->data.or.n-1; i++) {\n      mpc_print_unretained(p->data.or.xs[i], 0);\n      printf(\" | \");\n    }\n    mpc_print_unretained(p->data.or.xs[p->data.or.n-1], 0);\n    printf(\")\");\n  }\n  \n  if (p->type == MPC_TYPE_AND) {\n    printf(\"(\");\n    for(i = 0; i < p->data.and.n-1; i++) {\n      mpc_print_unretained(p->data.and.xs[i], 0);\n      printf(\" \");\n    }\n    mpc_print_unretained(p->data.and.xs[p->data.and.n-1], 0);\n    printf(\")\");\n  }\n  \n}\n\nvoid mpc_print(mpc_parser_t *p) {\n  mpc_print_unretained(p, 1);\n  printf(\"\\n\");\n}\n\n/*\n** Testing\n*/\n\n/*\n** These functions are slightly unwieldy and\n** also the whole of the testing suite for mpc\n** mpc is pretty shaky.\n**\n** It could do with a lot more tests and more\n** precision. Currently I am only really testing\n** changes off of the examples.\n**\n*/\n\nint mpc_test_fail(mpc_parser_t *p, const char *s, void *d,\n  int(*tester)(void*, void*),\n  mpc_dtor_t destructor,\n  void(*printer)(void*)) {\n\n  mpc_result_t r;  \n  if (mpc_parse(\"<test>\", s, p, &r)) {\n\n    if (tester(r.output, d)) {\n      destructor(r.output);\n      return 0;\n    } else {\n      destructor(r.output);\n      return 1;\n    }\n  \n  } else {\n    mpc_err_delete(r.error);\n    return 1;\n  }\n  \n}\n\nint mpc_test_pass(mpc_parser_t *p, const char *s, void *d,\n  int(*tester)(void*, void*), \n  mpc_dtor_t destructor, \n  void(*printer)(void*)) {\n\n  mpc_result_t r;  \n  if (mpc_parse(\"<test>\", s, p, &r)) {\n    \n    if (tester(r.output, d)) {\n      destructor(r.output);\n      return 1;\n    } else {\n      printf(\"Got \"); printer(r.output); printf(\"\\n\");\n      printf(\"Expected \"); printer(d); printf(\"\\n\");\n      destructor(r.output);\n      return 0;\n    }\n    \n  } else {    \n    mpc_err_print(r.error);\n    mpc_err_delete(r.error);\n    return 0;\n    \n  }\n  \n}\n\n\n/*\n** AST\n*/\n\nvoid mpc_ast_delete(mpc_ast_t *a) {\n  \n  int i;\n  \n  if (a == NULL) { return; }\n  for (i = 0; i < a->children_num; i++) {\n    mpc_ast_delete(a->children[i]);\n  }\n  \n  free(a->children);\n  free(a->tag);\n  free(a->contents);\n  free(a);\n  \n}\n\nstatic void mpc_ast_delete_no_children(mpc_ast_t *a) {\n  free(a->children);\n  free(a->tag);\n  free(a->contents);\n  free(a);\n}\n\nmpc_ast_t *mpc_ast_new(const char *tag, const char *contents) {\n  \n  mpc_ast_t *a = malloc(sizeof(mpc_ast_t));\n  \n  a->tag = malloc(strlen(tag) + 1);\n  strcpy(a->tag, tag);\n  \n  a->contents = malloc(strlen(contents) + 1);\n  strcpy(a->contents, contents);\n  \n  a->state = mpc_state_new();\n  \n  a->children_num = 0;\n  a->children = NULL;\n  return a;\n  \n}\n\nmpc_ast_t *mpc_ast_build(int n, const char *tag, ...) {\n  \n  mpc_ast_t *a = mpc_ast_new(tag, \"\");\n  \n  int i;\n  va_list va;\n  va_start(va, tag);\n  \n  for (i = 0; i < n; i++) {\n    mpc_ast_add_child(a, va_arg(va, mpc_ast_t*));\n  }\n  \n  va_end(va);\n  \n  return a;\n  \n}\n\nmpc_ast_t *mpc_ast_add_root(mpc_ast_t *a) {\n\n  mpc_ast_t *r;\n\n  if (a == NULL) { return a; }\n  if (a->children_num == 0) { return a; }\n  if (a->children_num == 1) { return a; }\n\n  r = mpc_ast_new(\">\", \"\");\n  mpc_ast_add_child(r, a);\n  return r;\n}\n\nint mpc_ast_eq(mpc_ast_t *a, mpc_ast_t *b) {\n  \n  int i;\n\n  if (strcmp(a->tag, b->tag) != 0) { return 0; }\n  if (strcmp(a->contents, b->contents) != 0) { return 0; }\n  if (a->children_num != b->children_num) { return 0; }\n  \n  for (i = 0; i < a->children_num; i++) {\n    if (!mpc_ast_eq(a->children[i], b->children[i])) { return 0; }\n  }\n  \n  return 1;\n}\n\nmpc_ast_t *mpc_ast_add_child(mpc_ast_t *r, mpc_ast_t *a) {\n  r->children_num++;\n  r->children = realloc(r->children, sizeof(mpc_ast_t*) * r->children_num);\n  r->children[r->children_num-1] = a;\n  return r;\n}\n\nmpc_ast_t *mpc_ast_add_tag(mpc_ast_t *a, const char *t) {\n  if (a == NULL) { return a; }\n  a->tag = realloc(a->tag, strlen(t) + 1 + strlen(a->tag) + 1);\n  memmove(a->tag + strlen(t) + 1, a->tag, strlen(a->tag)+1);\n  memmove(a->tag, t, strlen(t));\n  memmove(a->tag + strlen(t), \"|\", 1);\n  return a;\n}\n\nmpc_ast_t *mpc_ast_tag(mpc_ast_t *a, const char *t) {\n  a->tag = realloc(a->tag, strlen(t) + 1);\n  strcpy(a->tag, t);\n  return a;\n}\n\nmpc_ast_t *mpc_ast_state(mpc_ast_t *a, mpc_state_t s) {\n  if (a == NULL) { return a; }\n  a->state = s;\n  return a;\n}\n\nstatic void mpc_ast_print_depth(mpc_ast_t *a, int d) {\n  \n  int i;\n  for (i = 0; i < d; i++) { printf(\"  \"); }\n  \n  if (strlen(a->contents)) {\n    printf(\"%s:%i:%i '%s'\\n\", a->tag, a->state.row+1, a->state.col+1, a->contents);\n  } else {\n    printf(\"%s \\n\", a->tag);\n  }\n  \n  for (i = 0; i < a->children_num; i++) {\n    mpc_ast_print_depth(a->children[i], d+1);\n  }\n  \n}\n\nvoid mpc_ast_print(mpc_ast_t *a) {\n  mpc_ast_print_depth(a, 0);\n}\n\nmpc_val_t *mpcf_fold_ast(int n, mpc_val_t **xs) {\n  \n  int i, j;\n  mpc_ast_t** as = (mpc_ast_t**)xs;\n  mpc_ast_t *r;\n  \n  if (n == 0) { return NULL; }\n  if (n == 1) { return xs[0]; }\n  if (n == 2 && xs[1] == NULL) { return xs[0]; }\n  if (n == 2 && xs[0] == NULL) { return xs[1]; }\n  \n  r = mpc_ast_new(\">\", \"\");\n  \n  for (i = 0; i < n; i++) {\n    \n    if (as[i] == NULL) { continue; }\n    \n    if (as[i] && as[i]->children_num > 0) {\n      \n      for (j = 0; j < as[i]->children_num; j++) {\n        mpc_ast_add_child(r, as[i]->children[j]);\n      }\n      \n      mpc_ast_delete_no_children(as[i]);\n      \n    } else if (as[i] && as[i]->children_num == 0) {\n      mpc_ast_add_child(r, as[i]);\n    }\n  \n  }\n  \n  if (r->children_num) {\n    r->state = r->children[0]->state;\n  }\n  \n  return r;\n}\n\nmpc_val_t *mpcf_str_ast(mpc_val_t *c) {\n  mpc_ast_t *a = mpc_ast_new(\"\", c);\n  free(c);\n  return a;\n}\n\nmpc_val_t *mpcf_state_ast(int n, mpc_val_t **xs) {\n  mpc_state_t *s = ((mpc_state_t**)xs)[0];\n  mpc_ast_t *a = ((mpc_ast_t**)xs)[1];\n  a = mpc_ast_state(a, *s);\n  free(s);\n  return a;\n}\n\nmpc_parser_t *mpca_state(mpc_parser_t *a) {\n  return mpc_and(2, mpcf_state_ast, mpc_state(), a, free);\n}\n\nmpc_parser_t *mpca_tag(mpc_parser_t *a, const char *t) {\n  return mpc_apply_to(a, (mpc_apply_to_t)mpc_ast_tag, (void*)t);\n}\n\nmpc_parser_t *mpca_add_tag(mpc_parser_t *a, const char *t) {\n  return mpc_apply_to(a, (mpc_apply_to_t)mpc_ast_add_tag, (void*)t);\n}\n\nmpc_parser_t *mpca_root(mpc_parser_t *a) {\n  return mpc_apply(a, (mpc_apply_t)mpc_ast_add_root);\n}\n\nmpc_parser_t *mpca_not(mpc_parser_t *a) { return mpc_not(a, (mpc_dtor_t)mpc_ast_delete); }\nmpc_parser_t *mpca_maybe(mpc_parser_t *a) { return mpc_maybe(a); }\nmpc_parser_t *mpca_many(mpc_parser_t *a) { return mpc_many(mpcf_fold_ast, a); }\nmpc_parser_t *mpca_many1(mpc_parser_t *a) { return mpc_many1(mpcf_fold_ast, a); }\nmpc_parser_t *mpca_count(int n, mpc_parser_t *a) { return mpc_count(n, mpcf_fold_ast, a, (mpc_dtor_t)mpc_ast_delete); }\n\nmpc_parser_t *mpca_or(int n, ...) {\n\n  int i;\n  va_list va;\n\n  mpc_parser_t *p = mpc_undefined();\n  \n  p->type = MPC_TYPE_OR;\n  p->data.or.n = n;\n  p->data.or.xs = malloc(sizeof(mpc_parser_t*) * n);\n  \n  va_start(va, n);  \n  for (i = 0; i < n; i++) {\n    p->data.or.xs[i] = va_arg(va, mpc_parser_t*);\n  }\n  va_end(va);\n  \n  return p;\n  \n}\n\nmpc_parser_t *mpca_and(int n, ...) {\n  \n  int i;\n  va_list va;\n  \n  mpc_parser_t *p = mpc_undefined();\n  \n  p->type = MPC_TYPE_AND;\n  p->data.and.n = n;\n  p->data.and.f = mpcf_fold_ast;\n  p->data.and.xs = malloc(sizeof(mpc_parser_t*) * n);\n  p->data.and.dxs = malloc(sizeof(mpc_dtor_t) * (n-1));\n  \n  va_start(va, n);\n  for (i = 0; i < n; i++) {\n    p->data.and.xs[i] = va_arg(va, mpc_parser_t*);\n  }\n  for (i = 0; i < (n-1); i++) {\n    p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete;\n  }    \n  va_end(va);\n  \n  return p;  \n}\n\nmpc_parser_t *mpca_total(mpc_parser_t *a) { return mpc_total(a, (mpc_dtor_t)mpc_ast_delete); }\n\n/*\n** Grammar Parser\n*/\n\n/*\n** This is another interesting bootstrapping.\n**\n** Having a general purpose AST type allows\n** users to specify the grammar alone and\n** let all fold rules be automatically taken\n** care of by existing functions.\n**\n** You don't get to control the type spat\n** out but this means you can make a nice\n** parser to take in some grammar in nice\n** syntax and spit out a parser that works.\n**\n** The grammar for this looks surprisingly\n** like regex but the main difference is that\n** it is now whitespace insensitive and the\n** base type takes literals of some form.\n*/\n\n/*\n**\n**  ### Grammar Grammar\n**\n**      <grammar> : (<term> \"|\" <grammar>) | <term>\n**     \n**      <term> : <factor>*\n**\n**      <factor> : <base>\n**               | <base> \"*\"\n**               | <base> \"+\"\n**               | <base> \"?\"\n**               | <base> \"{\" <digits> \"}\"\n**           \n**      <base> : \"<\" (<digits> | <ident>) \">\"\n**             | <string_lit>\n**             | <char_lit>\n**             | <regex_lit>\n**             | \"(\" <grammar> \")\"\n*/\n\ntypedef struct {\n  va_list *va;\n  int parsers_num;\n  mpc_parser_t **parsers;\n  int flags;\n} mpca_grammar_st_t;\n\nstatic mpc_val_t *mpcaf_grammar_or(int n, mpc_val_t **xs) {\n  if (xs[1] == NULL) { return xs[0]; }\n  else { return mpca_or(2, xs[0], xs[1]); }\n}\n\nstatic mpc_val_t *mpcaf_grammar_and(int n, mpc_val_t **xs) {\n  int i;\n  mpc_parser_t *p = mpc_pass();  \n  for (i = 0; i < n; i++) {\n    if (xs[i] != NULL) { p = mpca_and(2, p, xs[i]); }\n  }\n  return p;\n}\n\nstatic mpc_val_t *mpcaf_grammar_repeat(int n, mpc_val_t **xs) {\n  \n  int num;\n  if (xs[1] == NULL) { return xs[0]; }  \n  if (strcmp(xs[1], \"*\") == 0) { free(xs[1]); return mpca_many(xs[0]); }\n  if (strcmp(xs[1], \"+\") == 0) { free(xs[1]); return mpca_many1(xs[0]); }\n  if (strcmp(xs[1], \"?\") == 0) { free(xs[1]); return mpca_maybe(xs[0]); }\n  if (strcmp(xs[1], \"!\") == 0) { free(xs[1]); return mpca_not(xs[0]); }\n  num = *((int*)xs[1]);\n  free(xs[1]);\n  return mpca_count(num, xs[0]);\n}\n\nstatic mpc_val_t *mpcaf_grammar_string(mpc_val_t *x, void *s) {\n  mpca_grammar_st_t *st = s;\n  char *y = mpcf_unescape(x);\n  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_string(y) : mpc_tok(mpc_string(y));\n  free(y);\n  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), \"string\"));\n}\n\nstatic mpc_val_t *mpcaf_grammar_char(mpc_val_t *x, void *s) {\n  mpca_grammar_st_t *st = s;\n  char *y = mpcf_unescape(x);\n  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_char(y[0]) : mpc_tok(mpc_char(y[0]));\n  free(y);\n  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), \"char\"));\n}\n\nstatic mpc_val_t *mpcaf_grammar_regex(mpc_val_t *x, void *s) {\n  mpca_grammar_st_t *st = s;\n  char *y = mpcf_unescape_regex(x);\n  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_re(y) : mpc_tok(mpc_re(y));\n  free(y);\n  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), \"regex\"));\n}\n\nstatic int is_number(const char* s) {\n  int i;\n  for (i = 0; i < strlen(s); i++) { if (!strchr(\"0123456789\", s[i])) { return 0; } }\n  return 1;\n}\n\nstatic mpc_parser_t *mpca_grammar_find_parser(char *x, mpca_grammar_st_t *st) {\n  \n  int i;\n  mpc_parser_t *p;\n  \n  /* Case of Number */\n  if (is_number(x)) {\n\n    i = strtol(x, NULL, 10);\n    \n    while (st->parsers_num <= i) {\n      st->parsers_num++;\n      st->parsers = realloc(st->parsers, sizeof(mpc_parser_t*) * st->parsers_num);\n      st->parsers[st->parsers_num-1] = va_arg(*st->va, mpc_parser_t*);\n      if (st->parsers[st->parsers_num-1] == NULL) {\n        return mpc_failf(\"No Parser in position %i! Only supplied %i Parsers!\", i, st->parsers_num);\n      }\n    }\n    \n    return st->parsers[st->parsers_num-1];\n  \n  /* Case of Identifier */\n  } else {\n    \n    /* Search Existing Parsers */\n    for (i = 0; i < st->parsers_num; i++) {\n      mpc_parser_t *p = st->parsers[i];\n      if (p->name && strcmp(p->name, x) == 0) { return p; }\n    }\n    \n    /* Search New Parsers */\n    while (1) {\n    \n      p = va_arg(*st->va, mpc_parser_t*);\n      \n      st->parsers_num++;\n      st->parsers = realloc(st->parsers, sizeof(mpc_parser_t*) * st->parsers_num);\n      st->parsers[st->parsers_num-1] = p;\n      \n      if (p == NULL) {\n        return mpc_failf(\"Unknown Parser '%s'!\", x);\n      }\n      \n      if (p->name && strcmp(p->name, x) == 0) { return p; }\n      \n    }\n  \n  }  \n  \n}\n\nstatic mpc_val_t *mpcaf_grammar_id(mpc_val_t *x, void *s) {\n  \n  mpca_grammar_st_t *st = s;\n  mpc_parser_t *p = mpca_grammar_find_parser(x, st);\n  free(x);\n\n  if (p->name) {\n    return mpca_state(mpca_root(mpca_add_tag(p, p->name)));\n  } else {\n    return mpca_state(mpca_root(p));\n  }\n}\n\nmpc_parser_t *mpca_grammar_st(const char *grammar, mpca_grammar_st_t *st) {\n  \n  char *err_msg;\n  mpc_parser_t *err_out;\n  mpc_result_t r;\n  mpc_parser_t *GrammarTotal, *Grammar, *Term, *Factor, *Base;\n  \n  GrammarTotal = mpc_new(\"grammar_total\");\n  Grammar = mpc_new(\"grammar\");\n  Term = mpc_new(\"term\");\n  Factor = mpc_new(\"factor\");\n  Base = mpc_new(\"base\");\n  \n  mpc_define(GrammarTotal,\n    mpc_predictive(mpc_total(Grammar, mpc_soft_delete))\n  );\n  \n  mpc_define(Grammar, mpc_and(2, mpcaf_grammar_or,\n    Term,\n    mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_sym(\"|\"), Grammar, free)),\n    mpc_soft_delete\n  ));\n  \n  mpc_define(Term, mpc_many1(mpcaf_grammar_and, Factor));\n  \n  mpc_define(Factor, mpc_and(2, mpcaf_grammar_repeat,\n    Base,\n      mpc_or(6,\n        mpc_sym(\"*\"),\n        mpc_sym(\"+\"),\n        mpc_sym(\"?\"),\n        mpc_sym(\"!\"),\n        mpc_tok_brackets(mpc_int(), free),\n        mpc_pass()),\n    mpc_soft_delete\n  ));\n  \n  mpc_define(Base, mpc_or(5,\n    mpc_apply_to(mpc_tok(mpc_string_lit()), mpcaf_grammar_string, st),\n    mpc_apply_to(mpc_tok(mpc_char_lit()),   mpcaf_grammar_char, st),\n    mpc_apply_to(mpc_tok(mpc_regex_lit()),  mpcaf_grammar_regex, st),\n    mpc_apply_to(mpc_tok_braces(mpc_or(2, mpc_digits(), mpc_ident()), free), mpcaf_grammar_id, st),\n    mpc_tok_parens(Grammar, mpc_soft_delete)\n  ));\n  \n  if(!mpc_parse(\"<mpc_grammar_compiler>\", grammar, GrammarTotal, &r)) {\n    err_msg = mpc_err_string(r.error);\n    err_out = mpc_failf(\"Invalid Grammar: %s\", err_msg);\n    mpc_err_delete(r.error);\n    free(err_msg);\n    r.output = err_out;\n  }\n  \n  mpc_cleanup(5, GrammarTotal, Grammar, Term, Factor, Base);\n  \n  return (st->flags & MPCA_LANG_PREDICTIVE) ? mpc_predictive(r.output) : r.output;\n  \n}\n\nmpc_parser_t *mpca_grammar(int flags, const char *grammar, ...) {\n  mpca_grammar_st_t st;\n  mpc_parser_t *res;\n  va_list va;\n  va_start(va, grammar);\n  \n  st.va = &va;\n  st.parsers_num = 0;\n  st.parsers = NULL;\n  st.flags = flags;\n  \n  res = mpca_grammar_st(grammar, &st);  \n  free(st.parsers);\n  va_end(va);\n  return res;\n}\n\ntypedef struct {\n  char *ident;\n  char *name;\n  mpc_parser_t *grammar;\n} mpca_stmt_t;\n\nstatic mpc_val_t *mpca_stmt_afold(int n, mpc_val_t **xs) {\n  \n  mpca_stmt_t *stmt = malloc(sizeof(mpca_stmt_t));\n  stmt->ident = ((char**)xs)[0];\n  stmt->name = ((char**)xs)[1];\n  stmt->grammar = ((mpc_parser_t**)xs)[3];\n  \n  free(((char**)xs)[2]);\n  free(((char**)xs)[4]);\n  \n  return stmt;\n}\n\nstatic mpc_val_t *mpca_stmt_fold(int n, mpc_val_t **xs) {\n  \n  int i;\n  mpca_stmt_t **stmts = malloc(sizeof(mpca_stmt_t*) * (n+1));\n  \n  for (i = 0; i < n; i++) {\n    stmts[i] = xs[i];\n  }\n  stmts[n] = NULL;  \n  \n  return stmts;\n}\n\nstatic void mpca_stmt_list_delete(mpc_val_t *x) {\n\n  mpca_stmt_t **stmts = x;\n\n  while(*stmts) {\n    mpca_stmt_t *stmt = *stmts; \n    free(stmt->ident);\n    free(stmt->name);\n    mpc_soft_delete(stmt->grammar);\n    free(stmt);  \n    stmts++;\n  }\n  free(x);\n\n}\n\nstatic mpc_val_t *mpca_stmt_list_apply_to(mpc_val_t *x, void *s) {\n\n  mpca_grammar_st_t *st = s;\n  mpca_stmt_t *stmt;\n  mpca_stmt_t **stmts = x;\n  mpc_parser_t *left;\n\n  while(*stmts) {\n    stmt = *stmts;\n    left = mpca_grammar_find_parser(stmt->ident, st);\n    if (st->flags & MPCA_LANG_PREDICTIVE) { stmt->grammar = mpc_predictive(stmt->grammar); }\n    if (stmt->name) { stmt->grammar = mpc_expect(stmt->grammar, stmt->name); }\n    mpc_define(left, stmt->grammar);\n    free(stmt->ident);\n    free(stmt->name);\n    free(stmt);\n    stmts++;\n  }\n  free(x);\n  \n  return NULL;\n}\n\nstatic mpc_err_t *mpca_lang_st(mpc_input_t *i, mpca_grammar_st_t *st) {\n  \n  mpc_result_t r;\n  mpc_err_t *e;\n  mpc_parser_t *Lang, *Stmt, *Grammar, *Term, *Factor, *Base; \n  \n  Lang    = mpc_new(\"lang\");\n  Stmt    = mpc_new(\"stmt\");\n  Grammar = mpc_new(\"grammar\");\n  Term    = mpc_new(\"term\");\n  Factor  = mpc_new(\"factor\");\n  Base    = mpc_new(\"base\");\n  \n  mpc_define(Lang, mpc_apply_to(\n    mpc_total(mpc_predictive(mpc_many(mpca_stmt_fold, Stmt)), mpca_stmt_list_delete),\n    mpca_stmt_list_apply_to, st\n  ));\n  \n  mpc_define(Stmt, mpc_and(5, mpca_stmt_afold,\n    mpc_tok(mpc_ident()), mpc_maybe(mpc_tok(mpc_string_lit())), mpc_sym(\":\"), Grammar, mpc_sym(\";\"),\n    free, free, mpc_soft_delete\n  ));\n  \n  mpc_define(Grammar, mpc_and(2, mpcaf_grammar_or,\n      Term,\n      mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_sym(\"|\"), Grammar, free)),\n      mpc_soft_delete\n  ));\n  \n  mpc_define(Term, mpc_many1(mpcaf_grammar_and, Factor));\n  \n  mpc_define(Factor, mpc_and(2, mpcaf_grammar_repeat,\n    Base,\n      mpc_or(6,\n        mpc_sym(\"*\"),\n        mpc_sym(\"+\"),\n        mpc_sym(\"?\"),\n        mpc_sym(\"!\"),\n        mpc_tok_brackets(mpc_int(), free),\n        mpc_pass()),\n    mpc_soft_delete\n  ));\n  \n  mpc_define(Base, mpc_or(5,\n    mpc_apply_to(mpc_tok(mpc_string_lit()), mpcaf_grammar_string, st),\n    mpc_apply_to(mpc_tok(mpc_char_lit()),   mpcaf_grammar_char, st),\n    mpc_apply_to(mpc_tok(mpc_regex_lit()),  mpcaf_grammar_regex, st),\n    mpc_apply_to(mpc_tok_braces(mpc_or(2, mpc_digits(), mpc_ident()), free), mpcaf_grammar_id, st),\n    mpc_tok_parens(Grammar, mpc_soft_delete)\n  ));\n  \n  \n  if (!mpc_parse_input(i, Lang, &r)) {\n    e = r.error;\n  } else {\n    e = NULL;\n  }\n  \n  mpc_cleanup(6, Lang, Stmt, Grammar, Term, Factor, Base);\n  \n  return e;\n}\n\nmpc_err_t *mpca_lang_file(int flags, FILE *f, ...) {\n  mpca_grammar_st_t st;\n  mpc_input_t *i;\n  mpc_err_t *err;\n\n  va_list va;  \n  va_start(va, f);\n  \n  st.va = &va;\n  st.parsers_num = 0;\n  st.parsers = NULL;\n  st.flags = flags;\n  \n  i = mpc_input_new_file(\"<mpca_lang_file>\", f);\n  err = mpca_lang_st(i, &st);\n  mpc_input_delete(i);\n  \n  free(st.parsers);\n  va_end(va);\n  return err;\n}\n\nmpc_err_t *mpca_lang_pipe(int flags, FILE *p, ...) {\n  mpca_grammar_st_t st;\n  mpc_input_t *i;\n  mpc_err_t *err;\n\n  va_list va;  \n  va_start(va, p);\n  \n  st.va = &va;\n  st.parsers_num = 0;\n  st.parsers = NULL;\n  st.flags = flags;\n  \n  i = mpc_input_new_pipe(\"<mpca_lang_pipe>\", p);\n  err = mpca_lang_st(i, &st);\n  mpc_input_delete(i);\n  \n  free(st.parsers);\n  va_end(va);\n  return err;\n}\n\nmpc_err_t *mpca_lang(int flags, const char *language, ...) {\n  \n  mpca_grammar_st_t st;\n  mpc_input_t *i;\n  mpc_err_t *err;\n  \n  va_list va;  \n  va_start(va, language);\n  \n  st.va = &va;\n  st.parsers_num = 0;\n  st.parsers = NULL;\n  st.flags = flags;\n  \n  i = mpc_input_new_string(\"<mpca_lang>\", language);\n  err = mpca_lang_st(i, &st);\n  mpc_input_delete(i);\n  \n  free(st.parsers);\n  va_end(va);\n  return err;\n}\n\nmpc_err_t *mpca_lang_contents(int flags, const char *filename, ...) {\n  \n  mpca_grammar_st_t st;\n  mpc_input_t *i;\n  mpc_err_t *err;\n  \n  va_list va;\n\n  FILE *f = fopen(filename, \"rb\");\n  \n  if (f == NULL) {\n    return mpc_err_fail(filename, mpc_state_new(), \"Unable to open file!\");\n  }\n  \n  va_start(va, filename);\n  \n  st.va = &va;\n  st.parsers_num = 0;\n  st.parsers = NULL;\n  st.flags = flags;\n  \n  i = mpc_input_new_file(filename, f);\n  err = mpca_lang_st(i, &st);\n  mpc_input_delete(i);\n  \n  free(st.parsers);\n  va_end(va);  \n  \n  fclose(f);\n  \n  return err;\n}\n","#include \"parser.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include \"mpc.h\"\n#include \"assert.h\"\n#include \"util.h\"\n\nstatic mpc_parser_t* Integer;\nstatic mpc_parser_t* FPoint;\nstatic mpc_parser_t* Number;\nstatic mpc_parser_t* Bool;\nstatic mpc_parser_t* String;\nstatic mpc_parser_t* Comment;\nstatic mpc_parser_t* Symbol;\nstatic mpc_parser_t* QSymbol;\nstatic mpc_parser_t* Sexpr;\nstatic mpc_parser_t* Qexpr;\nstatic mpc_parser_t* EExpr;\nstatic mpc_parser_t* CExpr;\nstatic mpc_parser_t* Expr;\nstatic mpc_parser_t* Awl;\n\nvoid setup_parser(void) {\n    Integer = mpc_new(\"integer\");\n    FPoint = mpc_new(\"fpoint\");\n    Number = mpc_new(\"number\");\n    Bool = mpc_new(\"bool\");\n    String = mpc_new(\"string\");\n    Comment = mpc_new(\"comment\");\n    Symbol = mpc_new(\"symbol\");\n    QSymbol = mpc_new(\"qsymbol\");\n    Sexpr = mpc_new(\"sexpr\");\n    Qexpr = mpc_new(\"qexpr\");\n    EExpr = mpc_new(\"eexpr\");\n    CExpr = mpc_new(\"cexpr\");\n    Expr = mpc_new(\"expr\");\n    Awl = mpc_new(\"awl\");\n\n    mpca_lang(MPCA_LANG_DEFAULT,\n        \"                                                                   \\\n        integer : /[+-]?[0-9]+/ ;                                           \\\n        fpoint  : /[+-]?[0-9]+\\\\.[0-9]*/ | /[+-]?[0-9]*\\\\.[0-9]+/ ;         \\\n        number  : <fpoint> | <integer> ;                                    \\\n        bool    : \\\"true\\\" | \\\"false\\\" ;                                    \\\n        string  : /\\\"(\\\\\\\\.|[^\\\"])*\\\"/ | /'(\\\\\\\\.|[^'])*'/ ;                \\\n        comment : /;[^\\\\r\\\\n]*/ ;                                           \\\n        symbol  : /[a-zA-Z0-9_+\\\\-*\\\\/=<>!\\\\?&%^$]+/ ;                      \\\n        qsymbol : ':' <symbol> ;                                            \\\n        sexpr   : '(' <expr>* ')' ;                                         \\\n        qexpr   : '{' <expr>* '}' ;                                         \\\n        eexpr   : '\\\\\\\\' <expr> ;                                           \\\n        cexpr   : '@' <expr> ;                                              \\\n        expr    : <number> | <bool> | <string> | <symbol> | <qsymbol> |     \\\n                  <comment> | <sexpr> | <qexpr> | <eexpr> | <cexpr> ;       \\\n        awl     : /^/ <expr>* /$/ ;                                         \\\n        \",\n        Integer, FPoint, Number, Bool, String, Comment, Symbol, QSymbol, Sexpr, Qexpr, EExpr, CExpr, Expr, Awl);\n}\n\nvoid teardown_parser(void) {\n    mpc_cleanup(12, Integer, FPoint, Number, Bool, String, Comment, Symbol, QSymbol, Sexpr, Qexpr, EExpr, CExpr, Expr, Awl);\n}\n\nstatic awlval* awlval_read_int(const mpc_ast_t* t) {\n    errno = 0;\n    long x = strtol(t->contents, NULL, 10);\n    return errno != ERANGE ? awlval_int(x) : awlval_err(\"invalid number: %s\", t->contents);\n}\n\nstatic awlval* awlval_read_float(const mpc_ast_t* t) {\n    errno = 0;\n    double x = strtod(t->contents, NULL);\n    return errno != ERANGE ? awlval_float(x) : awlval_err(\"invalid float: %s\", t->contents);\n}\n\nstatic awlval* awlval_read_bool(const mpc_ast_t* t) {\n    if (streq(t->contents, \"true\")) {\n        return awlval_bool(true);\n    }\n    return awlval_bool(false);\n}\n\nstatic awlval* awlval_read_string(const mpc_ast_t* t) {\n    t->contents[strlen(t->contents) - 1] = '\\0';\n\n    char* unescaped = malloc(strlen(t->contents + 1) + 1);\n    strcpy(unescaped, t->contents + 1);\n\n    unescaped = mpcf_unescape(unescaped);\n    awlval* str = awlval_str(unescaped);\n\n    free(unescaped);\n    return str;\n}\n\nstatic awlval* awlval_read_qsym(const mpc_ast_t* t) {\n    return awlval_qsym(t->children[1]->contents);\n}\n\nstatic awlval* awlval_read_sym(const mpc_ast_t* t) {\n    return awlval_sym(t->contents);\n}\n\nstatic awlval* awlval_read(const mpc_ast_t* t) {\n    if (strstr(t->tag, \"integer\")) {\n        return awlval_read_int(t);\n    }\n    if (strstr(t->tag, \"fpoint\")) {\n        return awlval_read_float(t);\n    }\n    if (strstr(t->tag, \"bool\")) {\n        return awlval_read_bool(t);\n    }\n    if (strstr(t->tag, \"string\")) {\n        return awlval_read_string(t);\n    }\n    if (strstr(t->tag, \"qsymbol\")) {\n        return awlval_read_qsym(t);\n    }\n    if (strstr(t->tag, \"symbol\")) {\n        return awlval_read_sym(t);\n    }\n\n    awlval* x = NULL;\n    /* If root '>' */\n    if (streq(t->tag, \">\")) {\n        x = awlval_sexpr();\n    }\n    else if (strstr(t->tag, \"sexpr\")) {\n        x = awlval_sexpr();\n    }\n    else if (strstr(t->tag, \"qexpr\")) {\n        x = awlval_qexpr();\n    }\n    else if (strstr(t->tag, \"eexpr\")) {\n        x = awlval_eexpr();\n    }\n    else if (strstr(t->tag, \"cexpr\")) {\n        x = awlval_cexpr();\n    }\n\n    for (int i = 0; i < t->children_num; i++) {\n        if (streq(t->children[i]->contents, \"(\")) { continue; }\n        if (streq(t->children[i]->contents, \")\")) { continue; }\n        if (streq(t->children[i]->contents, \"{\")) { continue; }\n        if (streq(t->children[i]->contents, \"}\")) { continue; }\n        if (streq(t->children[i]->contents, \":\")) { continue; }\n        if (streq(t->children[i]->contents, \"\\\\\")) { continue; }\n        if (streq(t->children[i]->contents, \"@\")) { continue; }\n        if (streq(t->children[i]->tag, \"regex\")) { continue; }\n        if (strstr(t->children[i]->tag, \"comment\")) { continue; }\n        x = awlval_add(x, awlval_read(t->children[i]));\n    }\n\n    return x;\n}\n\nbool awlval_parse(const char* input, awlval** v, char** err) {\n    mpc_result_t r;\n    if (mpc_parse(\"<stdin>\", input, Awl, &r)) {\n        *v = awlval_read(r.output);\n        mpc_ast_delete(r.output);\n        return true;\n    } else {\n        *err = mpc_err_string(r.error);\n        mpc_err_delete(r.error);\n        return false;\n    }\n}\n\nbool awlval_parse_file(const char* file, awlval** v, char** err) {\n    mpc_result_t r;\n    if (mpc_parse_contents(file, Awl, &r)) {\n        *v = awlval_read(r.output);\n        mpc_ast_delete(r.output);\n        return true;\n    } else {\n        *err = mpc_err_string(r.error);\n        mpc_err_delete(r.error);\n        return false;\n    }\n}\n","#include \"print.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"mpc.h\"\n#include \"assert.h\"\n#include \"util.h\"\n\n#define BUFSIZE 4096\n\nstatic void (*print_fn)(char*);\n\nstatic void default_print_fn(char* s) {\n    fputs(s, stdout);\n}\n\nvoid register_print_fn(void (*fn)(char*)) {\n    print_fn = fn;\n}\n\nvoid register_default_print_fn(void) {\n    print_fn = &default_print_fn;\n}\n\nvoid awl_printf(const char* format, ...) {\n    // TODO: Make it similar to stringbuilder_t?\n    char* buffer = malloc(BUFSIZE);\n    va_list arguments;\n    va_start(arguments, format);\n\n    vsnprintf(buffer, BUFSIZE, format, arguments);\n    print_fn(buffer);\n\n    va_end(arguments);\n    free(buffer);\n}\n\nvoid awlval_println(const awlval* v) {\n    awlval_print(v);\n    print_fn(\"\\n\");\n}\n\nvoid awlval_print(const awlval* v) {\n    print_fn(awlval_to_str(v));\n}\n\nstatic void awlval_expr_print(stringbuilder_t* sb, const awlval* v, const char* open, const char* close) {\n    stringbuilder_write(sb, open);\n    for (int i = 0; i < v->count; i++) {\n        awlval_print(v->cell[i]);\n\n        if (i != (v->count - 1)) {\n            stringbuilder_write(sb, \" \");\n        }\n    }\n    stringbuilder_write(sb, close);\n}\n\nstatic void awlval_print_str(stringbuilder_t* sb, const awlval* v) {\n    char* escaped = malloc(strlen(v->str) + 1);\n    strcpy(escaped, v->str);\n\n    escaped = mpcf_escape(escaped);\n    stringbuilder_write(sb, \"\\\"%s\\\"\", escaped);\n\n    free(escaped);\n}\n\nstatic void awlval_write_sb(stringbuilder_t* sb, const awlval* v) {\n    switch (v->type) {\n        case AWLVAL_ERR:\n            stringbuilder_write(sb, \"Error: %s\", v->err);\n            break;\n\n        case AWLVAL_INT:\n            stringbuilder_write(sb, \"%li\", v->lng);\n            break;\n\n        case AWLVAL_FLOAT:\n            stringbuilder_write(sb, \"%f\", v->dbl);\n            break;\n\n        case AWLVAL_SYM:\n            stringbuilder_write(sb, \"%s\", v->sym);\n            break;\n\n        case AWLVAL_QSYM:\n            stringbuilder_write(sb, \":%s\", v->sym);\n            break;\n\n        case AWLVAL_STR:\n            awlval_print_str(sb, v);\n            break;\n\n        case AWLVAL_BOOL:\n            if (v->bln) {\n                stringbuilder_write(sb, \"true\");\n            } else {\n                stringbuilder_write(sb, \"false\");\n            }\n            break;\n\n        case AWLVAL_BUILTIN:\n            stringbuilder_write(sb, \"<builtin %s>\", v->builtin_name);\n            break;\n\n        case AWLVAL_FN:\n            stringbuilder_write(sb, \"(fn \");\n            awlval_write_sb(sb, v->formals);\n            stringbuilder_write(sb, \" \");\n            awlval_write_sb(sb, v->body);\n            stringbuilder_write(sb, \")\");\n            break;\n\n        case AWLVAL_MACRO:\n            stringbuilder_write(sb, \"(macro \");\n            awlval_write_sb(sb, v->formals);\n            stringbuilder_write(sb, \" \");\n            awlval_write_sb(sb, v->body);\n            stringbuilder_write(sb, \")\");\n            break;\n\n        case AWLVAL_SEXPR:\n            awlval_expr_print(sb, v, \"(\", \")\");\n            break;\n\n        case AWLVAL_QEXPR:\n            awlval_expr_print(sb, v, \"{\", \"}\");\n            break;\n\n        case AWLVAL_EEXPR:\n            awlval_expr_print(sb, v, \"\\\\\", \"\");\n            break;\n\n        case AWLVAL_CEXPR:\n            awlval_expr_print(sb, v, \"@\", \"\");\n            break;\n    }\n}\n\nchar* awlval_to_str(const awlval* v) {\n    stringbuilder_t* sb = stringbuilder_new();\n    awlval_write_sb(sb, v);\n    char* str = stringbuilder_to_str(sb);\n    stringbuilder_del(sb);\n    return str;\n}\n","#include \"repl.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n\n#include \"awl.h\"\n#include \"assert.h\"\n#include \"parser.h\"\n#include \"print.h\"\n#include \"eval.h\"\n\n#define HIST_FILE \"awl.hist\"\n\n#if defined(_WIN32)\n\n#include <stdio.h>\n#include <string.h>\n\n#define REPL_MAX_INPUT 2048\nstatic char buffer[REPL_MAX_INPUT];\n\nchar* get_input(char* prompt) {\n    fputs(prompt, stdout);\n    fflush(stdout);\n    fgets(buffer, REPL_MAX_INPUT, stdin);\n\n    char* copy = malloc(strlen(buffer) + 1);\n    strcpy(copy, buffer);\n    copy[strlen(copy) - 1] = '\\0';\n    return copy;\n}\n\nvoid load_history() {\n}\n\nvoid add_history(char* unused) {\n}\n\n#else\n\n#include \"linenoise.h\"\n\nchar* get_input(char* prompt) {\n    return linenoise(prompt);\n}\n\nvoid load_history() {\n    linenoiseHistoryLoad(HIST_FILE);\n}\n\nvoid add_history(char* input) {\n    linenoiseHistoryAdd(input);\n    linenoiseHistorySave(HIST_FILE);\n}\n\n#endif\n\nawlval* eval_repl(awlenv* e, awlval* v) {\n    if (v->count == 0) {\n        awlval_del(v);\n        return awlval_qexpr();\n    }\n    if (v->count != 1) {\n        awlval_del(v);\n        return awlval_err(\"too many expressions in REPL; only one is allowed\");\n    }\n    return awlval_eval(e, awlval_take(v, 0));\n}\n\nvoid eval_repl_str(awlenv* e, const char* input) {\n    awlval* v;\n    char* err;\n    if (awlval_parse(input, &v, &err)) {\n        awlval* x = eval_repl(e, v);\n        awlval_println(x);\n        awlval_del(x);\n    } else {\n        awl_printf(\"%s\", err);\n        free(err);\n    }\n}\n\nstatic void sigint_handler(int ignore) {\n    awlval_eval_abort();\n}\n\nstatic void setup_sigint_handler(void) {\n    signal(SIGINT, sigint_handler);\n}\n\nstatic bool repl_aborted = false;\n\nvoid abort_repl(void) {\n    repl_aborted = true;\n}\n\nvoid run_repl(awlenv* e) {\n    setup_sigint_handler();\n\n    awl_printf(\"awl %s\\n\", get_awl_version());\n    awl_printf(\"Ctrl+D to exit\\n\\n\");\n\n    load_history();\n\n    while (!repl_aborted) {\n        errno = 0;\n        char* input = get_input(\"awl> \");\n        if (!input) {\n            if (errno == EAGAIN) {\n                continue;\n            } else {\n                awl_printf(\"\\n\");\n                break;\n            }\n        }\n        add_history(input);\n        eval_repl_str(e, input);\n        free(input);\n    }\n}\n","#include \"types.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <errno.h>\n\n#include \"assert.h\"\n#include \"builtins.h\"\n#include \"print.h\"\n#include \"util.h\"\n\n#define AWLENV_INITIAL_SIZE 16\n#define AWLENV_PROBE_INTERVAL 1\n#define AWLENV_LOAD_FACTOR 0.75\n#define AWLENV_GROWTH_FACTOR 2\n\nchar* awlval_type_name(awlval_type_t t) {\n    switch (t) {\n        case AWLVAL_ERR: return \"Error\";\n        case AWLVAL_INT: return \"Integer\";\n        case AWLVAL_FLOAT: return \"Float\";\n        case AWLVAL_BUILTIN: return \"Builtin\";\n        case AWLVAL_FN: return \"Function\";\n        case AWLVAL_MACRO: return \"Macro\";\n        case AWLVAL_SYM: return \"Symbol\";\n        case AWLVAL_QSYM: return \"Q-Symbol\";\n        case AWLVAL_STR: return \"String\";\n        case AWLVAL_BOOL: return \"Boolean\";\n        case AWLVAL_SEXPR: return \"S-Expression\";\n        case AWLVAL_QEXPR: return \"Q-Expression\";\n        case AWLVAL_EEXPR: return \"E-Expression\";\n        case AWLVAL_CEXPR: return \"C-Expression\";\n        default: return \"Unknown\";\n    }\n}\n\nchar* awlval_type_sysname(awlval_type_t t) {\n    switch (t) {\n        case AWLVAL_ERR: return \"err\";\n        case AWLVAL_INT: return \"int\";\n        case AWLVAL_FLOAT: return \"float\";\n        case AWLVAL_BUILTIN: return \"builtin\";\n        case AWLVAL_FN: return \"fn\";\n        case AWLVAL_MACRO: return \"macro\";\n        case AWLVAL_SYM: return \"sym\";\n        case AWLVAL_QSYM: return \"qsym\";\n        case AWLVAL_STR: return \"str\";\n        case AWLVAL_BOOL: return \"bool\";\n        case AWLVAL_SEXPR: return \"sexpr\";\n        case AWLVAL_QEXPR: return \"qexpr\";\n        case AWLVAL_EEXPR: return \"eexpr\";\n        case AWLVAL_CEXPR: return \"cexpr\";\n        default: return \"unknown\";\n    }\n}\n\nawlval_type_t awlval_parse_sysname(const char* sysname) {\n    /* Ordering reflects most common types first */\n    if (streq(sysname, \"int\")) {\n        return AWLVAL_INT;\n    } else if (streq(sysname, \"float\")) {\n        return AWLVAL_FLOAT;\n    } else if (streq(sysname, \"str\")) {\n        return AWLVAL_STR;\n    } else if (streq(sysname, \"bool\")) {\n        return AWLVAL_BOOL;\n    } else if (streq(sysname, \"qsym\")) {\n        return AWLVAL_QSYM;\n    } else if (streq(sysname, \"qexpr\")) {\n        return AWLVAL_QEXPR;\n    } else if (streq(sysname, \"err\")) {\n        return AWLVAL_ERR;\n    } else if (streq(sysname, \"builtin\")) {\n        return AWLVAL_BUILTIN;\n    } else if (streq(sysname, \"fn\")) {\n        return AWLVAL_FN;\n    } else if (streq(sysname, \"macro\")) {\n        return AWLVAL_MACRO;\n    } else if (streq(sysname, \"sym\")) {\n        return AWLVAL_SYM;\n    } else if (streq(sysname, \"sexpr\")) {\n        return AWLVAL_SEXPR;\n    } else if (streq(sysname, \"eexpr\")) {\n        return AWLVAL_EEXPR;\n    } else if (streq(sysname, \"cexpr\")) {\n        return AWLVAL_CEXPR;\n    } else {\n        errno = EINVAL;\n        return 0;\n    }\n}\n\nawlval* awlval_err(const char* fmt, ...) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_ERR;\n\n    va_list va;\n    va_start(va, fmt);\n\n    v->err = malloc(512);\n    vsnprintf(v->err, 512, fmt, va);\n\n    unsigned int l = strlen(v->err) + 1;\n    v->err = realloc(v->err, l);\n    v->err[l - 1] = '\\0';\n\n    va_end(va);\n\n    return v;\n}\n\nawlval* awlval_int(long x) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_INT;\n    v->lng = x;\n    return v;\n}\n\nawlval* awlval_float(double x) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_FLOAT;\n    v->dbl = x;\n    return v;\n}\n\nstatic awlval* awlval_sym_base(const char* s) {\n    awlval* v = malloc(sizeof(awlval));\n    v->length = strlen(s);\n    v->sym = malloc(strlen(s) + 1);\n    strcpy(v->sym, s);\n    return v;\n}\n\nawlval* awlval_sym(const char* s) {\n    awlval* v = awlval_sym_base(s);\n    v->type = AWLVAL_SYM;\n    return v;\n}\n\nawlval* awlval_qsym(const char* s) {\n    awlval* v = awlval_sym_base(s);\n    v->type = AWLVAL_QSYM;\n    return v;\n}\n\nawlval* awlval_str(const char* s) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_STR;\n    v->length = strlen(s);\n    v->str = malloc(v->length + 1);\n    strcpy(v->str, s);\n    return v;\n}\n\nawlval* awlval_bool(bool b) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_BOOL;\n    v->bln = b;\n    return v;\n}\n\nawlval* awlval_fun(const awlbuiltin builtin, const char* builtin_name) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_BUILTIN;\n    v->builtin = builtin;\n    v->builtin_name = malloc(strlen(builtin_name) + 1);\n    strcpy(v->builtin_name, builtin_name);\n    return v;\n}\n\nawlval* awlval_lambda(awlenv* closure, awlval* formals, awlval* body) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_FN;\n    v->env = awlenv_new();\n    v->env->parent = closure->top_level ? closure : awlenv_copy(closure);\n    v->formals = formals;\n    v->body = body;\n    v->called = false;\n    return v;\n}\n\nawlval* awlval_macro(awlenv* closure, awlval* formals, awlval* body) {\n    awlval* v = awlval_lambda(closure, formals, body);\n    v->type = AWLVAL_MACRO;\n    return v;\n}\n\nawlval* awlval_sexpr(void) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_SEXPR;\n    v->count = 0;\n    v->length = 0;\n    v->cell = NULL;\n    return v;\n}\n\nawlval* awlval_qexpr(void) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_QEXPR;\n    v->count = 0;\n    v->length = 0;\n    v->cell = NULL;\n    return v;\n}\n\nawlval* awlval_eexpr(void) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_EEXPR;\n    v->count = 0;\n    v->length = 0;\n    v->cell = NULL;\n    return v;\n}\n\nawlval* awlval_cexpr(void) {\n    awlval* v = malloc(sizeof(awlval));\n    v->type = AWLVAL_CEXPR;\n    v->count = 0;\n    v->length = 0;\n    v->cell = NULL;\n    return v;\n}\n\nvoid awlval_del(awlval* v) {\n    switch (v->type) {\n        case AWLVAL_INT:\n            break;\n\n        case AWLVAL_FLOAT:\n            break;\n\n        case AWLVAL_BUILTIN:\n            free(v->builtin_name);\n            break;\n\n        case AWLVAL_FN:\n        case AWLVAL_MACRO:\n            awlenv_del(v->env);\n            awlval_del(v->formals);\n            awlval_del(v->body);\n            break;\n\n        case AWLVAL_ERR:\n            free(v->err);\n            break;\n\n        case AWLVAL_SYM:\n        case AWLVAL_QSYM:\n            free(v->sym);\n            break;\n\n        case AWLVAL_STR:\n            free(v->str);\n            break;\n\n        case AWLVAL_BOOL:\n            break;\n\n        case AWLVAL_SEXPR:\n        case AWLVAL_QEXPR:\n        case AWLVAL_EEXPR:\n        case AWLVAL_CEXPR:\n            for (int i = 0; i < v->count; i++) {\n                awlval_del(v->cell[i]);\n            }\n            free(v->cell);\n            break;\n    }\n\n    free(v);\n}\n\nawlval* awlval_add(awlval* v, awlval* x) {\n    v->count++;\n    v->length++;\n    v->cell = realloc(v->cell, sizeof(awlval*) * v->count);\n    v->cell[v->count - 1] = x;\n    return v;\n}\n\nawlval* awlval_add_front(awlval* v, awlval* x) {\n    v->count++;\n    v->length++;\n    v->cell = realloc(v->cell, sizeof(awlval*) * v->count);\n    if (v->count > 1) {\n        memmove(&v->cell[1], &v->cell[0], sizeof(awlval*) * (v->count - 1));\n    }\n    v->cell[0] = x;\n    return v;\n}\n\nawlval* awlval_pop(awlval* v, int i) {\n    awlval* x = v->cell[i];\n\n    memmove(&v->cell[i], &v->cell[i + 1], sizeof(awlval*) * (v->count - i - 1));\n    v->count--;\n    v->length--;\n\n    v->cell = realloc(v->cell, sizeof(awlval*) * v->count);\n    return x;\n}\n\nawlval* awlval_take(awlval* v, int i) {\n    awlval* x = awlval_pop(v, i);\n    awlval_del(v);\n    return x;\n}\n\nawlval* awlval_join(awlval* x, awlval* y) {\n    while (y->count) {\n        x = awlval_add(x, awlval_pop(y, 0));\n    }\n\n    awlval_del(y);\n    return x;\n}\n\nawlval* awlval_insert(awlval* x, awlval* y, int i) {\n    x->count++;\n    x->length++;\n    x->cell = realloc(x->cell, sizeof(awlval*) * x->count);\n\n    memmove(&x->cell[i + 1], &x->cell[i], sizeof(awlval*) * (x->count - i - 1));\n    x->cell[i] = y;\n    return x;\n}\n\nawlval* awlval_shift(awlval* x, awlval* y, int i) {\n    while (y->count) {\n        x = awlval_insert(x, awlval_pop(y, y->count - 1), i);\n    }\n\n    awlval_del(y);\n    return x;\n}\n\nstatic awlval* awlval_reverse_qexpr(awlval* x) {\n    awlval* y = awlval_qexpr();\n    while (x->count) {\n        y = awlval_add(y, awlval_pop(x, x->count - 1));\n    }\n    awlval_del(x);\n    return y;\n}\n\nstatic awlval* awlval_reverse_qsym(awlval* x) {\n    char* reversed = strrev(x->sym);\n    free(x->sym);\n    x->sym = reversed;\n    return x;\n}\n\nstatic awlval* awlval_reverse_str(awlval* x) {\n    char* reversed = strrev(x->str);\n    free(x->str);\n    x->str = reversed;\n    return x;\n}\n\nawlval* awlval_reverse(awlval* x) {\n    if (x->type == AWLVAL_QEXPR) {\n        return awlval_reverse_qexpr(x);\n    } else if (x->type == AWLVAL_STR) {\n        return awlval_reverse_str(x);\n    } else {\n        return awlval_reverse_qsym(x);\n    }\n}\n\nstatic awlval* awlval_slice_step_qexpr(awlval* x, int start, int end, int step) {\n    /* Remove from front */\n    while (start) {\n        awlval_del(awlval_pop(x, 0));\n        start--; end--;\n    }\n    /* Remove from back */\n    while (end < x->count) {\n        awlval_del(awlval_pop(x, end));\n    }\n    /* Remove by steps */\n    if (step > 1 && x->count) {\n        int final_count = x->count / step + (x->count % step == 0 ? 0 : 1),\n            multiplier = 0,\n            removal_offset = 0;\n\n        while (x->count > final_count) {\n            for (int i = 1; i < step; i++) {\n                int idx = multiplier * step + i - removal_offset;\n                awlval_del(awlval_pop(x, idx));\n                removal_offset++;\n            }\n            multiplier++;\n        }\n    }\n    return x;\n}\n\nstatic awlval* awlval_slice_step_str(awlval* x, int start, int end, int step) {\n    char* sliced = strsubstr(x->str, start, end);\n    if (step > 1 && strlen(sliced)) {\n        char* stepped = strstep(sliced, step);\n        free(sliced);\n        sliced = stepped;\n    }\n    free(x->str);\n    x->str = sliced;\n    return x;\n}\n\nstatic awlval* awlval_slice_step_qsym(awlval* x, int start, int end, int step) {\n    char* sliced = strsubstr(x->sym, start, end);\n    if (step > 1 && strlen(sliced)) {\n        char* stepped = strstep(sliced, step);\n        free(sliced);\n        sliced = stepped;\n    }\n    free(x->sym);\n    x->sym = sliced;\n    return x;\n}\n\nawlval* awlval_slice_step(awlval* x, int start, int end, int step) {\n    if (x->type == AWLVAL_QEXPR) {\n        return awlval_slice_step_qexpr(x, start, end, step);\n    } else if (x->type == AWLVAL_STR) {\n        return awlval_slice_step_str(x, start, end, step);\n    } else {\n        return awlval_slice_step_qsym(x, start, end, step);\n    }\n}\n\nawlval* awlval_slice(awlval* x, int start, int end) {\n    return awlval_slice_step(x, start, end, 1);\n}\n\nvoid awlval_maybe_promote_numeric(awlval* a, awlval* b) {\n    if (!(ISNUMERIC(a->type) && ISNUMERIC(b->type))) {\n        return;\n    }\n    if (a->type == AWLVAL_FLOAT || b->type == AWLVAL_FLOAT) {\n        awlval_promote_numeric(a);\n        awlval_promote_numeric(b);\n    }\n}\n\nvoid awlval_promote_numeric(awlval* x) {\n    if (x->type != AWLVAL_FLOAT) {\n        x->type = AWLVAL_FLOAT;\n        x->dbl = (double)x->lng;\n    }\n}\n\nvoid awlval_demote_numeric(awlval* x) {\n    if (x->type != AWLVAL_INT) {\n        x->type = AWLVAL_INT;\n        x->lng = (long)x->dbl;\n    }\n}\n\nawlval* awlval_copy(const awlval* v) {\n    awlval* x = malloc(sizeof(awlval));\n    x->type = v->type;\n\n    switch (v->type) {\n        case AWLVAL_BUILTIN:\n            x->builtin = v->builtin;\n            x->builtin_name = malloc(strlen(v->builtin_name) + 1);\n            strcpy(x->builtin_name, v->builtin_name);\n            break;\n\n        case AWLVAL_FN:\n        case AWLVAL_MACRO:\n            x->env = awlenv_copy(v->env);\n            x->formals = awlval_copy(v->formals);\n            x->body = awlval_copy(v->body);\n            x->called = v->called;\n            break;\n\n        case AWLVAL_INT:\n            x->lng = v->lng;\n            break;\n\n        case AWLVAL_FLOAT:\n            x->dbl = v->dbl;\n            break;\n\n        case AWLVAL_ERR:\n            x->err = malloc(strlen(v->err) + 1);\n            strcpy(x->err, v->err);\n            break;\n\n        case AWLVAL_SYM:\n        case AWLVAL_QSYM:\n            x->length = v->length;\n            x->sym = malloc(strlen(v->sym) + 1);\n            strcpy(x->sym, v->sym);\n            break;\n\n        case AWLVAL_STR:\n            x->length = v->length;\n            x->str = malloc(strlen(v->str) + 1);\n            strcpy(x->str, v->str);\n            break;\n\n        case AWLVAL_BOOL:\n            x->bln = v->bln;\n            break;\n\n        case AWLVAL_SEXPR:\n        case AWLVAL_QEXPR:\n        case AWLVAL_EEXPR:\n        case AWLVAL_CEXPR:\n            x->count = v->count;\n            x->length = v->length;\n            x->cell = malloc(sizeof(awlval*) * x->count);\n            for (int i = 0; i < x->count; i++) {\n                x->cell[i] = awlval_copy(v->cell[i]);\n            }\n            break;\n    }\n\n    return x;\n}\n\nawlval* awlval_convert(awlval_type_t t, const awlval* v) {\n    if (v->type == t) {\n        return awlval_copy(v);\n    }\n\n    switch (t) {\n        case AWLVAL_INT:\n            switch (v->type) {\n                case AWLVAL_FLOAT:\n                    return awlval_int((long)v->dbl);\n                    break;\n\n                case AWLVAL_STR:\n                    {\n                        errno = 0;\n                        long x = strtol(v->str, NULL, 10);\n                        return errno != ERANGE ? awlval_int(x) : awlval_err(\"invalid number: %s\", v->str);\n                    }\n                    break;\n\n                case AWLVAL_BOOL:\n                    return awlval_int(v->bln);\n                    break;\n\n                default:\n                    return awlval_err(\"a direct conversion from type %s to type %s does not exist\",\n                            awlval_type_name(v->type), awlval_type_name(t));\n                    break;\n            }\n            break;\n\n        case AWLVAL_FLOAT:\n            switch (v->type) {\n                case AWLVAL_INT:\n                    return awlval_float((double)v->lng);\n                    break;\n\n                case AWLVAL_STR:\n                    {\n                        errno = 0;\n                        double x = strtod(v->str, NULL);\n                        return errno != ERANGE ? awlval_float(x) : awlval_err(\"invalid float: %s\", v->str);\n                    }\n                    break;\n\n                case AWLVAL_BOOL:\n                    return awlval_float((double)v->bln);\n                    break;\n\n                default:\n                    return awlval_err(\"a direct conversion from type %s to type %s does not exist\",\n                            awlval_type_name(v->type), awlval_type_name(t));\n                    break;\n            }\n            break;\n\n        case AWLVAL_STR:\n            if (v->type == AWLVAL_QSYM) {\n                return awlval_str(v->sym);\n            } else {\n                char* str = awlval_to_str(v);\n                awlval* res = awlval_str(str);\n                free(str);\n                return res;\n            }\n            break;\n\n        case AWLVAL_BOOL:\n            switch (v->type) {\n                case AWLVAL_INT:\n                    return awlval_bool(v->lng != 0 ? true : false);\n                    break;\n\n                case AWLVAL_FLOAT:\n                    return awlval_bool(v->dbl != 0.0 ? true : false);\n                    break;\n\n                default:\n                    return awlval_err(\"a direct conversion from type %s to type %s does not exist\",\n                            awlval_type_name(v->type), awlval_type_name(t));\n                    break;\n            }\n            break;\n\n        case AWLVAL_QSYM:\n            switch (v->type) {\n                case AWLVAL_STR:\n                    return awlval_qsym(v->str);\n                    break;\n\n                default:\n                    return awlval_err(\"a direct conversion from type %s to type %s does not exist\",\n                            awlval_type_name(v->type), awlval_type_name(t));\n                    break;\n            }\n            break;\n\n        default:\n            return awlval_err(\"no type can be directly converted to type %s\", awlval_type_name(t));\n            break;\n    }\n}\n\nbool awlval_eq(awlval* x, awlval* y) {\n    awlval_maybe_promote_numeric(x, y);\n    if (x->type != y->type) {\n        return false;\n    }\n\n    switch (x->type) {\n        case AWLVAL_BUILTIN:\n            return y->type == AWLVAL_BUILTIN && x->builtin == y->builtin;\n            break;\n\n        case AWLVAL_FN:\n        case AWLVAL_MACRO:\n            return y->type == x->type && awlval_eq(x->formals, y->formals) && awlval_eq(x->body, y->body);\n            break;\n\n        case AWLVAL_INT:\n            return x->lng == y->lng;\n            break;\n\n        case AWLVAL_FLOAT:\n            return x->dbl == y->dbl;\n            break;\n\n        case AWLVAL_ERR:\n            return streq(x->err, y->err);\n            break;\n\n        case AWLVAL_SYM:\n        case AWLVAL_QSYM:\n            return x->length == y->length && streq(x->sym, y->sym);\n            break;\n\n        case AWLVAL_STR:\n            return x->length == y->length && streq(x->str, y->str);\n            break;\n\n        case AWLVAL_BOOL:\n            return x->bln == y->bln;\n            break;\n\n        case AWLVAL_SEXPR:\n        case AWLVAL_QEXPR:\n        case AWLVAL_EEXPR:\n        case AWLVAL_CEXPR:\n            if (x->count != y->count) {\n                return false;\n            }\n            for (int i = 0; i < x->count; i++) {\n                if (!awlval_eq(x->cell[i], y->cell[i])) {\n                    return false;\n                }\n            }\n            return true;\n            break;\n    }\n    return false;\n}\n\nawlenv* awlenv_new(void) {\n    awlenv* e = malloc(sizeof(awlenv));\n    e->parent = NULL;\n    e->size = AWLENV_INITIAL_SIZE;\n    e->count = 0;\n    e->syms = malloc(sizeof(char*) * AWLENV_INITIAL_SIZE);\n    for (int i = 0; i < AWLENV_INITIAL_SIZE; i++) {\n        e->syms[i] = NULL;\n    }\n    e->vals = malloc(sizeof(awlenv*) * AWLENV_INITIAL_SIZE);\n    e->locked = malloc(sizeof(bool) * AWLENV_INITIAL_SIZE);\n    e->top_level = false;\n    return e;\n}\n\nawlenv* awlenv_new_top_level(void) {\n    awlenv* e = awlenv_new();\n    e->top_level = true;\n    awlenv_add_builtins(e);\n    awlenv_add_core_lib(e);\n    return e;\n}\n\nvoid awlenv_del(awlenv* e) {\n    if (e->parent && !e->parent->top_level) {\n        awlenv_del(e->parent);\n    }\n    for (int i = 0; i < e->size; i++) {\n        if (e->syms[i]) {\n            free(e->syms[i]);\n            awlval_del(e->vals[i]);\n        }\n    }\n    free(e->syms);\n    free(e->vals);\n    free(e->locked);\n    free(e);\n}\n\nstatic unsigned int awlenv_hash(const char* str) {\n    /* djb2 hash */\n    unsigned int hash = 5381;\n    for (int i = 0; str[i]; i++) {\n        /* XOR hash * 33 with current char val */\n        hash = ((hash << 5) + hash) ^ str[i];\n    }\n    return hash;\n}\n\nstatic int awlenv_findslot(awlenv* e, char* k) {\n    unsigned int i = awlenv_hash(k) % e->size;\n    unsigned int probe = 1;\n    while (e->syms[i] && !streq(e->syms[i], k)) {\n        i = (i + probe) % e->size;\n        probe += AWLENV_PROBE_INTERVAL;\n    }\n    return i;\n}\n\nstatic awlval* awlenv_lookup(awlenv* e, char* k) {\n    int i = awlenv_findslot(e, k);\n    if (e->syms[i]) {\n        return awlval_copy(e->vals[i]);\n    }\n\n    /* check parent if no symbol found */\n    if (e->parent) {\n        return awlenv_lookup(e->parent, k);\n    } else {\n        return awlval_err(\"unbound symbol '%s'\", k);\n    }\n}\n\n/* forward declaration */\nstatic void awlenv_resize(awlenv* e);\n\nstatic void awlenv_set(awlenv* e, char* k, awlval* v, bool locked) {\n    int i = awlenv_findslot(e, k);\n    if (e->syms[i]) {\n        awlval_del(e->vals[i]);\n        e->vals[i] = awlval_copy(v);\n        return;\n    }\n\n    /* no existing entry found */\n    e->count++;\n    /* resize if needed */\n    if (e->count / (float)e->size >= AWLENV_LOAD_FACTOR) {\n        awlenv_resize(e);\n        i = awlenv_findslot(e, k);\n    }\n    e->syms[i] = malloc(strlen(k) + 1);\n    strcpy(e->syms[i], k);\n    e->vals[i] = awlval_copy(v);\n    e->locked[i] = locked;\n}\n\nstatic void awlenv_resize(awlenv* e) {\n    int oldsize = e->size;\n    e->size = e->size * AWLENV_GROWTH_FACTOR;\n\n    char** syms = e->syms;\n    awlval** vals = e->vals;\n    bool* locked = e->locked;\n\n    e->syms = malloc(sizeof(char*) * e->size);\n    for (int i = 0; i < e->size; i++) {\n        e->syms[i] = NULL;\n    }\n    e->vals = malloc(sizeof(awlval*) * e->size);\n    e->locked = malloc(sizeof(bool) * e->size);\n\n    for (int i = 0; i < oldsize; i++) {\n        if (syms[i]) {\n            awlenv_set(e, syms[i], vals[i], locked[i]);\n            free(syms[i]);\n            awlval_del(vals[i]);\n        }\n    }\n    free(syms);\n    free(vals);\n    free(locked);\n}\n\nint awlenv_index(awlenv* e, awlval* k) {\n    int i = awlenv_findslot(e, k->sym);\n    if (!e->syms[i]) {\n        i = -1;\n    }\n    return i;\n}\n\nawlval* awlenv_get(awlenv* e, awlval* k) {\n    return awlenv_lookup(e, k->sym);\n}\n\nvoid awlenv_put(awlenv* e, awlval* k, awlval* v, bool locked) {\n    awlenv_set(e, k->sym, v, locked);\n}\n\nvoid awlenv_put_global(awlenv* e, awlval* k, awlval* v, bool locked) {\n    while (e->parent) {\n        e = e->parent;\n    }\n    awlenv_set(e, k->sym, v, locked);\n}\n\nawlenv* awlenv_copy(awlenv* e) {\n    awlenv* n = malloc(sizeof(awlenv));\n    n->parent = e->parent && !e->parent->top_level ? awlenv_copy(e->parent) : e->parent;\n    n->size = e->size;\n    n->count = e->count;\n    n->syms = malloc(sizeof(char*) * e->size);\n    for (int i = 0; i < e->size; i++) {\n        n->syms[i] = NULL;\n    }\n    n->vals = malloc(sizeof(awlval*) * e->size);\n    n->locked = malloc(sizeof(bool) * e->size);\n\n    for (int i = 0; i < e->size; i++) {\n        if (e->syms[i]) {\n            awlenv_set(n, e->syms[i], e->vals[i], e->locked[i]);\n        }\n    }\n    n->top_level = e->top_level;\n\n    return n;\n}\n\nvoid awlenv_add_builtin(awlenv* e, char* name, awlbuiltin builtin) {\n    awlval* k = awlval_sym(name);\n    awlval* v = awlval_fun(builtin, name);\n    awlenv_put(e, k, v, true);\n    awlval_del(k);\n    awlval_del(v);\n}\n\nvoid awlenv_add_builtins(awlenv* e) {\n    awlenv_add_builtin(e, \"+\", builtin_add);\n    awlenv_add_builtin(e, \"-\", builtin_sub);\n    awlenv_add_builtin(e, \"*\", builtin_mul);\n    awlenv_add_builtin(e, \"/\", builtin_div);\n    awlenv_add_builtin(e, \"//\", builtin_trunc_div);\n    awlenv_add_builtin(e, \"%\", builtin_mod);\n    awlenv_add_builtin(e, \"^\", builtin_pow);\n\n    awlenv_add_builtin(e, \">\", builtin_gt);\n    awlenv_add_builtin(e, \">=\", builtin_gte);\n    awlenv_add_builtin(e, \"<\", builtin_lt);\n    awlenv_add_builtin(e, \"<=\", builtin_lte);\n\n    awlenv_add_builtin(e, \"==\", builtin_eq);\n    awlenv_add_builtin(e, \"!=\", builtin_neq);\n\n    awlenv_add_builtin(e, \"and\", builtin_and);\n    awlenv_add_builtin(e, \"or\", builtin_or);\n    awlenv_add_builtin(e, \"not\", builtin_not);\n\n    awlenv_add_builtin(e, \"head\", builtin_head);\n    awlenv_add_builtin(e, \"qhead\", builtin_qhead);\n    awlenv_add_builtin(e, \"tail\", builtin_tail);\n    awlenv_add_builtin(e, \"first\", builtin_first);\n    awlenv_add_builtin(e, \"last\", builtin_last);\n    awlenv_add_builtin(e, \"list\", builtin_list);\n    awlenv_add_builtin(e, \"eval\", builtin_eval);\n    awlenv_add_builtin(e, \"append\", builtin_append);\n    awlenv_add_builtin(e, \"cons\", builtin_cons);\n    awlenv_add_builtin(e, \"except-last\", builtin_exceptlast);\n\n    awlenv_add_builtin(e, \"len\", builtin_len);\n    awlenv_add_builtin(e, \"reverse\", builtin_reverse);\n    awlenv_add_builtin(e, \"slice\", builtin_slice);\n\n    awlenv_add_builtin(e, \"if\", builtin_if);\n    awlenv_add_builtin(e, \"define\", builtin_define);\n    awlenv_add_builtin(e, \"global\", builtin_global);\n\n    awlenv_add_builtin(e, \"let\", builtin_let);\n    awlenv_add_builtin(e, \"fn\", builtin_lambda);\n    awlenv_add_builtin(e, \"macro\", builtin_macro);\n\n    awlenv_add_builtin(e, \"typeof\", builtin_typeof);\n    awlenv_add_builtin(e, \"convert\", builtin_convert);\n    awlenv_add_builtin(e, \"import\", builtin_import);\n    awlenv_add_builtin(e, \"print\", builtin_print);\n    awlenv_add_builtin(e, \"println\", builtin_println);\n    awlenv_add_builtin(e, \"random\", builtin_random);\n    awlenv_add_builtin(e, \"error\", builtin_error);\n    awlenv_add_builtin(e, \"exit\", builtin_exit);\n}\n\nvoid awlenv_add_core_lib(awlenv* e) {\n    char* awl_base = get_base_path();\n\n    char* corelib = path_join(awl_base, \"lib/core\");\n\n    awlval* args = awlval_sexpr();\n    args = awlval_add(args, awlval_str(corelib));\n    awlval_del(builtin_import(e, args));\n\n    free(awl_base);\n    free(corelib);\n}\n","#include \"util.h\"\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <libgen.h>\n#include <unistd.h>\n\n#define BUFSIZE 4096\n#define SB_START_SIZE 1024\n#define SB_GROWTH_FACTOR 2\n\nstringbuilder_t* stringbuilder_new(void) {\n    stringbuilder_t* sb = malloc(sizeof(stringbuilder_t));\n    sb->length = 0;\n    sb->size = SB_START_SIZE;\n    sb->str = malloc(SB_START_SIZE);\n    return sb;\n}\n\nstatic void stringbuilder_resize(stringbuilder_t* sb) {\n    sb->size = sb->size * SB_GROWTH_FACTOR;\n    char* str = sb->str;\n\n    sb->str = malloc(sb->size);\n    memcpy(sb->str, str, sb->length);\n\n    free(str);\n}\n\nvoid stringbuilder_write(stringbuilder_t* sb, const char* format, ...) {\n    va_list arguments1;\n    va_list arguments2;\n    va_start(arguments1, format);\n    va_copy(arguments2, arguments1);\n\n    /* First use vsnprintf to check how large the printed result would be */\n    int count = vsnprintf(NULL, 0, format, arguments1);\n\n    /* If there isn't enough room, keep resizing until there is */\n    int required_size = sb->length + count + 1;\n    while (sb->size < required_size) {\n        stringbuilder_resize(sb);\n    }\n\n    vsnprintf((sb->str + sb->length), count + 1, format, arguments2);\n    sb->length += count;\n\n    va_end(arguments1);\n    va_end(arguments2);\n}\n\nchar* stringbuilder_to_str(stringbuilder_t* sb) {\n    char* buffer = malloc(sb->length + 1);\n    memcpy(buffer, sb->str, sb->length + 1);\n    return buffer;\n}\n\nvoid stringbuilder_del(stringbuilder_t* sb) {\n    free(sb->str);\n    free(sb);\n}\n\nbool streq(const char* a, const char* b) {\n    return strcmp(a, b) == 0;\n}\n\nchar* strrev(const char* str) {\n    int len = strlen(str);\n    char* newstr = malloc(len + 1);\n\n    char* start = newstr;\n    const char* end = str + len - 1;\n\n    for (int i = 0; i < len; i++) {\n        *start = *end;\n        start++;\n        end--;\n    }\n    newstr[len] = '\\0';\n    return newstr;\n}\n\nchar* strsubstr(const char* str, int start, int end) {\n    int len = end - start;\n    char* buffer = malloc(len + 1);\n    memcpy(buffer, &str[start], len);\n    buffer[len] = '\\0';\n    return buffer;\n}\n\nchar* strstep(const char* str, int step) {\n    int len = strlen(str);\n    int bufferlen = len / step + (len % step == 0 ? 0 : 1);\n    char* buffer = malloc(bufferlen + 1);\n    for (int i = 0, j = 0; i < bufferlen; i++, j += step) {\n        buffer[i] = str[j];\n    }\n    buffer[bufferlen] = '\\0';\n    return buffer;\n}\n\nchar* get_executable_path(void) {\n    /* TODO: reading /proc is definitely not cross platform */\n    char* path = malloc(BUFSIZE);\n\n    int len = readlink(\"/proc/self/exe\", path, BUFSIZE - 1);\n    if (len == -1) {\n        free(path);\n        path = NULL;\n    } else {\n        path[len] = '\\0';\n    }\n    return path;\n}\n\nchar* get_base_path(void) {\n#ifdef EMSCRIPTEN\n    char* base_path = malloc(2);\n    base_path[0] = '.';\n    base_path[1] = '\\0';\n    return base_path;\n#else\n    // Executable is in 'bin' directory, so we need to go up twice\n    char* exe_path = get_executable_path();\n    char* base_path = path_join(dirname(exe_path), \"../\");\n    free(exe_path);\n    return base_path;\n#endif\n}\n\nchar* path_join(const char* a, const char* b) {\n    char* buffer = malloc(BUFSIZE);\n    snprintf(buffer, BUFSIZE, \"%s/%s\", a, b);\n    return buffer;\n}\n"]}